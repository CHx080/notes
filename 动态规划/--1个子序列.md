子序列和子数组的区别在于子数组必须是原数组中连续的一部分,但是子序列可以是非连续的,但是相对位置不变

由于其非连续的特性,**在更新状态时需要考虑之前的所有状态**,而不是只需要考虑前一个状态,特定题目可以用散列表代替DP数组

==**DP数组定义为以i位置为结尾的最优值**==

### 严格递增子序列长度 

https://leetcode.cn/problems/longest-increasing-subsequence/description/

对于某一个元素值,它可以拼接在它前面的任何元素之后形成子序列,也可以单独成序列

```c++
int lengthOfLIS(vector<int>& nums) {
    int n=nums.size();
    vector<int> dp(n,1);
    /* dp[i]::= 以i为结尾的严格递增子序列长度 */
    int res=1;
    for(int i=1;i<n;++i){
        for(int j=i-1;j>-1;--j)
            if(nums[j]<nums[i]) dp[i]=max(dp[i],dp[j]+1); //保证右端最大
        res=max(res,dp[i]);
    }
    return res;
}
```

### 严格递增子序列个数 

https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/

```c++
int findNumberOfLIS(vector<int>& nums) {
    int n=nums.size();
    vector<int> dpLen(n),dpCnt(n);
        /*  (以i结尾的...) dpLen表长度  dpCnt表个数       */
    int maxLen=0;
    for(int i=0;i<n;++i){
        dpLen[i]=dpCnt[i]=1;
        for(int j=0;j<i;++j){
            if(nums[j]>=nums[i]) continue;
            if(dpLen[j]+1==dpLen[i]) dpCnt[i]+=dpCnt[j];
            else if(dpLen[j]+1>dpLen[i]){ /* 出现了更长的递增子序列重新计数 */
                dpLen[i]=dpLen[j]+1;
                dpCnt[i]=dpCnt[j];
            }
        }
        maxLen=max(maxLen,dpLen[i]);
    }
    int res=0;
    for(int i=0;i<n;++i) if(dpLen[i]==maxLen) res+=dpCnt[i];
    return res;
}
```

### 删列造序III 

https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/description/

*把矩阵的每一列视作数组的一个元素*

**只需要找出最长的递增子序列,将数组长度减去最长递增子序列的长度就是删除的最少列数**

![img](https://pic.leetcode.cn/1737944353-adxVQB-lQDPJxPxwEcFgInNAe7NBP-w97Yjjb97G0EHevqbgXAiAA_1279_494.jpg)

```c++
bool isValid(vector<string>& strs,int i,int j){
    for(string& s:strs)
        if(s[j]>s[i]) return false;
    return true;
}
int minDeletionSize(vector<string>& strs) {
    int n=strs[0].size();	//n是矩阵列数
    int maxLen=0;
    vector<int> dp(n,1); //dp(i)::=最长递增子序列(以[i]为结尾)
    for(int i=0;i<n;++i){
        for(int j=0;j<i;++j)
            if(isValid(strs,i,j)) dp[i]=max(dp[j]+1,dp[i]);
        maxLen=max(maxLen,dp[i]);
    }
    return n-maxLen;
}
```

### 最长定差子序列 

https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/

```c++
int longestSubsequence(vector<int>& arr, int dif) { /* 超时 */
    int n=arr.size();
    int res=0;
    vector<int> dp(n,1); /* dp[i]::=以下标i位置为结尾的最长定差序列长度 */
    for(int i=0;i<n;++i){
        for(int j=0;j<i;++j)
            if(arr[i]-arr[j]==dif) dp[i]=max(dp[i],dp[j]+1);
        res=max(res,dp[i]);
    }
    return res;
}
```

```c++
int longestSubsequence(vector<int>& arr, int dif) {
    int n=arr.size();
    int res=0;
    unordered_map<int,int> hash; /* hash[arr[i]]::=以arr[i]为结尾的最长定差序列长度 */
    for(int i=0;i<n;++i){
        if(hash.count(arr[i]-dif)) hash[arr[i]]=hash[arr[i]-dif]+1;
        else hash[arr[i]]=1;
        res=max(res,hash[arr[i]]);
    }
    return res;
}
```

### 摆动序列 

https://leetcode.cn/problems/wiggle-subsequence/description/

```c++
int wiggleMaxLength(vector<int>& nums) {
    int n=nums.size();
    vector<int> f(n,1),g(n,1);
     /*
         f[i]::=以i位置为结尾的最长摆动序列长度 且 序列末项>序列次末项
         g[i]::=         ......            且 序列末项<序列次末项
     */
    int res=0;
    for(int i=0;i<n;++i){
        for(int j=0;j<i;++j){
            if(nums[j]<nums[i]) f[i]=max(f[i],g[j]+1);
            if(nums[j]>nums[i]) g[i]=max(g[i],f[j]+1);
        }
        res=max(res,max(f[i],g[i]));
    }
    return res;
}
```

### 区间覆盖-灌溉花园 

https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/

```c++
int minTaps(int n, vector<int>& r) {
    int res=0x3f3f3f3f;
    vector<int> dp(n+1,0x3f3f3f3f);
    /* dp[i]::=灌溉到0~i+r[i]所需要的最少水龙头数目 */
    for(int i=0;i<=n;++i){
        if(i-r[i]<=0) dp[i]=1;
        else{
            for(int j=0;j<i;++j)
                if(j+r[j]>=i-r[i])
                    dp[i]=min(dp[j]+1,dp[i]);
        }
        if(i+r[i]>=n) res=min(res,dp[i]);
    }
    return res==0x3f3f3f3f?-1:res;
}
```

