# 固定子集和

## 分割等和子集

https://leetcode.cn/problems/partition-equal-subset-sum/description/

*可视为背包问题*

```c++
bool canPartition(vector<int>& nums) {
    int sum=accumulate(nums.begin(),nums.end(),0);
    if(sum%2==1) return false;
    int n=nums.size();
    auto dp=vector(n+1,vector(sum/2+1,false));
    //dp(i,j)前i个元素中是否存在和为j的子集
    dp[0][0]=true; /*空集和记位0*/
    for(int i=1;i<=n;++i)
        for(int j=0;j<=sum/2;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=nums[i-1]) dp[i][j]=dp[i][j]||dp[i-1][j-nums[i-1]];
        }
    return dp[n][sum/2];
}
```

## 目标和

https://leetcode.cn/problems/target-sum/description/

*可视为背包问题*

```c++
int findTargetSumWays(vector<int>& nums, int target) {
    int sum=accumulate(nums.begin(),nums.end(),0);
    int n=nums.size(),m=(sum+target)/2;
    if(m<0 or (sum+target)%2) return 0;
    auto dp=vector(n+1,vector(m+1,0));
    dp[0][0]=1;  
    for(int i=1;i<=n;++i){
        for(int j=0;j<=m;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=nums[i-1]) dp[i][j]+=dp[i-1][j-nums[i-1]];
        }
    }
    for(int i=0;i<=n;++i) cout<<dp[i][0]<<endl;
    return dp[n][m];
}
```

## 目标总和III

https://leetcode.cn/problems/combination-sum-iii/description/

```c++

```

# 最优子集和

# 二维子集和

# 子集yuan'su