# 适配器

适配器模式将原本不兼容的接口粘合在一起，实现不兼容接口之间的合作。本质上适配器是一层目的为统一对外接口的封装。适配器分为**类适配器**和**对象适配器**，类适配器基于多继承，对象适配器基于组合。

***适配器所配接的2个对象是没有依赖关系的，这是与代理模式最大的不同，代理模式中代理者必须依赖被代理对象***

**UML:**

![image-20250205205948340](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205205948340.png)

```c++
class Target{
public:
    virutal void funcA()=0;
};
class Adaptee{
public:
    virtual void funcC()=0;
};
class Adapter : public Target,public Adaptee{ /*类适配器*/
public:
    void funcA override(){funcC();}
};
class Adapter : public Target{				/*对象适配器*/
	Adaptee* adaptee;
public:
    void funcA override(){adaptee->funcC();}
};
```

*适配器模式少使用*

# 代理※

代理模式为某个对象提供一种中介代理，用于实现这个对象的访问。被代理的对象不适合或者不能直接引用。代理者依赖被代理对象。代理模式可以细分为**保护代理、虚拟代理、远程代理、缓存代理**

**代理者和被代理对象具有相同的基类**

**UML:**

![image-20250205212512114](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205212512114.png)

```c++
class Subject{
public:
    virtual void func()=0;
}
class RealSubject{
public:
    void func() override{}
};
class Proxy : public Subject{
	RealSubject* real;
public:
    void func() override{
        /*访问控制*/
        /*合法则转发*/ real->func();
        /*不合法不转发*/
    }
};
```

# 桥接

桥接模式利用**可分离聚合关系**代替继承关系，实现类之间的弱关联。避免了多个继承带来的类臃肿。如果增加新的类，只需要在已有的架构基础上增加新的实现。

# 装饰

# 外观

# 享元

# 组合