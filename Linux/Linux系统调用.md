# 系统调用必要性
系统调用是操作系统提供给程序的一组接口，用于执行核心级别的任务。这些任务通常涉及到硬件资源的直接操作或需要特权模式，例如文件操作、网络通信、进程管理等。

> 1. 资源访问控制：操作系统通过系统调用来控制对底层硬件资源的访问，确保只有授权的进程才能进行特定的操作，从而保护系统的安全性和稳定性。
>
>  2. 抽象层：系统调用提供了硬件与软件之间的抽象层，使得开发者可以不必关心具体的硬件细节，而是使用统一的接口来完成任务。
>  3. 安全性：通过系统调用机制，操作系统可以有效地阻止潜在的恶意行为，比如未授权的数据访问或破坏系统稳定性的操作。
>

## Linux常用的系统调用

> 1. 文件操作
> open()：打开一个文件或设备，返回一个文件描述符
> read() 和 write()：从文件读取数据或将数据写入到文件
> close()：关闭已打开的文件
> 2. 进程管理
> fork()：创建一个新的子进程，新进程是调用进程的一个副本
> exec()：在一个进程中加载并运行新的程序
> exit()：终止当前进程，并可能传递退出状态给父进程
> wait() 和 waitpid()：等待一个或多个子进程结束，回收子进程占用的资源
> 3. 内存管理
> brk()和mmap():来分配和释放内存
> 4. 网络通信
> socket()：创建一个套接字，用于网络通信
> bind()：将一个本地地址绑定到一个套接字上
> listen()：监听一个套接字上的连接请求
> accept()：接受一个连接请求，建立与客户端的连接
> connect()：发起一个连接请求，尝试连接到服务器
> send() 和 recv()：发送和接收数据包

# 系统调用弊端

系统调用虽然能很好为程序员提供请求内核处理的接口，但它是有明显缺点的。

- 使用不便，系统调用接口原始，需要结合相关手册才能正确使用
- 可移植性差，不同系统的API各不相同
- 时间成本相对高，系统调用都会涉及内核用户态的切换

# 系统调用原理

Linux环境CPU可以在2种特权级别下运行，分别为==用户模式==和==内核模式==,*又称用户态(管态)和内核态(目态)*。CPU在不同状态下具有不同的执行权限，系统进程运行在内核态用于管理各项资源，保证系统的稳定性和安全性。应用程序运行装载用户态收到诸多限制。

应用程序不会一直处于用户态，当应用程序涉及到文件操作等请求时必须内核介入，需要使用系统调用，而系统调用就会导致CPU的状态切换。操作系统通过==中断==实现用户态到内核态。

## 中断

所谓中断就是硬件或软件发出的请求，要求CPU暂停当前逻辑跳转到其他地址处处理优先级更高的任务。中断有2个属性字段构成，==中断号和中断处理程序==。

中断发生就产生一个中断号，CPU需要根据中断号执行相应的中断处理程序。内核为每一个中断号注册了一个中断处理程序，并通过==中断向量表==来维护这种映射关系。CPU可以通过访问中断向量表获取中断处理程序的地址，跳转并处理后返回继续执行被中断的逻辑。

![image-20241116112813828](https://img-blog.csdnimg.cn/img_convert/f41ec47bce54702f4a72bc0c76816348.png)

中断可分为==硬件中断==和==软件中断==。系统调用所产生的中断属于软件中断，软件中断是一条指令(*interrupt-简称int*)。指令具有一个参数标识中断号，Linux种系统调用的中断号为**0x80**

## Linux系统调用

Linux为每一个系统调用分配了一个==系统调用号==作为唯一标识符，当应用程序进行系统调用时，eax寄存器会保存系统调用号。同时产生**int 0x80**中断CPU切换到内核态。CPU根据中断向量表获取中断处理程序地址，这个中断处理程序其实是一次间接函数跳转，内部维护了一张==系统调用表==，它负责根据系统调用号来调用具体的函数。随后返回至用户态。

![image-20241116115341756](https://img-blog.csdnimg.cn/img_convert/f7b31f289b913659a2690eaf63519f2b.png)

![image-20241116114002169](https://img-blog.csdnimg.cn/img_convert/2538f2319aeced2a3dceea4780b8bec7.png)

### 堆栈切换

**用户态和内核态使用的是不同的栈**，CPU在执行中断处理程序之前需要切换**栈**，2种状态下维护的栈维护各自的函数栈帧。esp用于维护栈顶，当esp的值位于用户态地址范围是就是用户栈，位于内核态地址范围就是内核栈。

**用户态----->内核态**

1. *保存当前用户态下的esp值*
2. *esp指向内核栈顶*

**内核态----->用户态**

1. *保存当前内核态下的esp值*
2. *esp指向用户栈顶*

----------

### 系统调用传参
Linux下的系统调用一般参数不会超过6个，系统调用的参数一般通过寄存器来进行传递。根据系统调用参数数量的不同，可以将参数依次写入ebx,ecx,edx,esi,edi,ebp六个寄存器。在进入系统调用服务程序system_call时通过一个宏命令SAVE_ALL保存各个寄存器。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6fec683eb2bd45d68b569dec16cae993.png)

