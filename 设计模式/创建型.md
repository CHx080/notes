# 单例

> 单例模式：全局唯一的对象

**UML:**

![image-20250129152109584](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250129152109584.png)

**懒汉单例**：程序启动即初始化

```c++
class Single{
private:
    Single(){}   //构造函数私有化，使外部无法实例化
public:
    static Single* getInstance(){
		return self;
    }

    Single(const Single&)=delete;
    const Single& operator=(const Single&)=delete;
    
private:
    static Single* self;
};
Single* Single::self=new Single;
```

-------

**饿汉单例**：用时初始化

```c++
class Single{
private:
    Single(){}
public:
    static Single* getInstance(){
        static Single* self=new Single;
        return self;
        //C++11后static对象实例化线程安全
    }
    Single(const Single&)=delete;
    const Single& operator=(const Single&)=delete;
};
```



**优点：**仅存在一份实例，不会多次构造和销毁对象，减少内存开销

**缺点：**单例对象没有虚接口函数，难以扩展

# 原型

**UML:**

![image-20250203194918993](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250203194918993.png)

对于构造函数复杂的对象定义clone方法以实现复制功能

使用原型模型时需要注意**深浅拷贝问题**

```c++
class PrototypeComputer {
public:
    virtual PrototypeComputer* clone() = 0;
};
class Computer : public PrototypeComputer {
public:
    Computer(string cpu, string gpu, string memory, string disk, string keyboard, string mouse)
        : cpu(cpu), gpu(gpu), memory(memory), disk(disk), keyboard(keyboard), mouse(mouse)
    {}
    PrototypeComputer* clone() override {
        return new Computer(*this);
    }
    /* setCpu,setGpu,... */
private:
    string cpu;
    string gpu;
    string memory;
    string disk;
    string keyboard;
    string mouse;
};
/* 使用clone方法可以什么麻烦的传参操作 */
```

> *如果有一个基类指针指向一个派生类对象，希望通过这个基类指针复制出派生类对象，拷贝构造函数就无法直接实现这一点。因为拷贝构造函数需要在编译时知道具体的类型，而原型模式通过`clone`接口可以在运行时动态决定复制的对象类型。*

