# 整数拆分

https://leetcode.cn/problems/integer-break/description/

```c++
int integerBreak(int n) {
    vector<int> dp(n+1);dp[2]=1;
    //dp(i)::=整数i的.......最大乘积 dp(0)=dp(1)=0;
    for(int i=3;i<=n;++i)
        for(int j=1;j<i;++j)
            dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)));
    //先拆为2个数,固定一个考虑另一个是否拆解
    return dp[n];
}
```

# 二叉搜索树数目

https://leetcode.cn/problems/unique-binary-search-trees/description/

```c++
int numTrees(int n) {
    vector<int> dp(n+1);dp[0]=dp[1]=1;
    //dp(i)表示i个有序数形成的二叉搜索树数目,dp(0)哨兵值
    for(int i=2;i<=n;++i)
        for(int j=0;j<i;++j)
            dp[i]+=dp[j]*dp[i-j-1];
    return dp[n];
}
```

# 真二叉树

https://leetcode.cn/problems/all-possible-full-binary-trees/description/

```c++
vector<TreeNode*> allPossibleFBT(int n) {
    if(n%2==0) return {};
    vector<vector<TreeNode*>> dp(n+1);dp[1]={new TreeNode(0)};
    //dp(i)::i个节点可形成的真二叉树数目
    for(int i=3;i<=n;i+=2)
        for(int j=1;j<i;j+=2) //左子树j个节点+右子树i-1-j个节点
            for(TreeNode* left:dp[j])
                for(TreeNode* right:dp[i-1-j]){
                    TreeNode* node=new TreeNode(0);
                    node->left=left;
                    node->right=right;
                    dp[i].push_back(node);
                }
    return dp[n];
}
```

