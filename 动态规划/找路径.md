# 找路径

## 最小路径和

https://leetcode.cn/problems/minimum-path-sum/description/

```c++
int minPathSum(vector<vector<int>>& grid) {
    int m=grid.size(),n=grid[0].size();
    vector<vector<int>> dp(m+1,vector<int>(n+1,0x3f3f3f3f));
    dp[0][1]=0; //保证dp[1][1]正确赋值
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n;++j)
            dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i-1][j-1];
    return dp[m][n];
}
```

## 下降路径最小和 I

https://leetcode.cn/problems/minimum-falling-path-sum/description/

```c++
int minFallingPathSum(vector<vector<int>>& matrix) {
    int m=matrix.size(),n=matrix[0].size();
    vector<vector<int>> dp(m,vector<int>(n+2,0x3f3f3f3f));
    /* 左右二列凑数 , 列坐标偏移1 */
    for(int j=1;j<=n;++j) dp[0][j]=matrix[0][j-1];
    for(int i=1;i<m;++i)
        for(int j=1;j<=n;++j)
            dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i-1][j+1]))+matrix[i][j-1];
    return *min_element(dp.back().begin(),dp.back().end());
}
```

## 下降路径最小和 II

https://leetcode.cn/problems/minimum-falling-path-sum-ii/description/

```c++
int minFallingPathSum(vector<vector<int>>& matrix) {
    int m=matrix.size(),n=matrix[0].size();
    vector<vector<int>> dp(m+1,vector<int>(n+2,0x3f3f3f3f));
    /* 上侧一行凑数 , 左右二列凑数 , 行列坐标偏移1 */
    int firstMin=0,secondMin=0,firstIdx=0;
    /* 上一行的最小值和次小值及其下标 */
    for(int i=1;i<=m;++i){
        int _fmin=0x3f3f3f3f,_smin=0x3f3f3f3f,_fidx=0;
        for(int j=1;j<=n;++j){
            int v=firstIdx!=j?firstMin:secondMin;
            dp[i][j]=matrix[i-1][j-1]+v;
            if(dp[i][j]<_fmin){
                _smin=_fmin;
                _fmin=dp[i][j],_fidx=j;
            }else if(dp[i][j]<_smin){_smin=dp[i][j];}
        }
        firstMin=_fmin,secondMin=_smin,firstIdx=_fidx;
    }
    return *min_element(dp.back().begin(),dp.back().end());        
}
```

## 三角形最小路径和

https://leetcode.cn/problems/triangle/description/

```c++
int minimumTotal(vector<vector<int>>& triangle) {
    int n=triangle.size();
    vector<vector<int>> dp(n+1,vector<int>(n+1,0x3f3f3f3f));
    dp[0][0]=0;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=i;++j)
            dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i-1][j-1];
    return *min_element(dp[n].begin(),dp[n].end());
}
```

## 不同路径 I

https://leetcode.cn/problems/unique-paths/description/

```c++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m+1,vector<int>(n+1));
    dp[0][1]=1;
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n;++j)
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
    return dp[m][n];
}
```

## 不同路径 II

https://leetcode.cn/problems/unique-paths-ii/description/ *(障碍物)*

```c++
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m=obstacleGrid.size(),n=obstacleGrid[0].size();
    vector<vector<int>> dp(m+1,vector<int>(n+1));
    dp[0][1]=1;
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n;++j){
            if(obstacleGrid[i-1][j-1]) continue;
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    return dp[m][n];
}
```

## 最大得分的路径数目

https://leetcode.cn/problems/number-of-paths-with-max-score/description/

```c++

```

