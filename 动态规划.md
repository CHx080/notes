# 普通子序列

> 严格递增子序列长度 https://leetcode.cn/problems/longest-increasing-subsequence/description/
>
> ```c++
> int lengthOfLIS(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dp(n,1);
>     /* dp[i]::= 以i为结尾的严格递增子序列长度 */
>     int res=1;
>     for(int i=1;i<n;++i){
>         for(int j=i-1;j>-1;--j)
>             if(nums[j]<nums[i]) dp[i]=max(dp[i],dp[j]+1); //保证右端最大
>         res=max(res,dp[i]);
>     }
>     return res;
> }
> ```

> 严格递增子序列个数 https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/
>
> ```c++
> int findNumberOfLIS(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dpLen(n),dpCnt(n);
>     /* (以i结尾的...)
>     	dpLen表长度
>     	dpCnt表个数
>     */
>     int maxLen=0;
>     for(int i=0;i<n;++i){
>         dpLen[i]=dpCnt[i]=1;
>         for(int j=0;j<i;++j){
>             if(nums[j]>=nums[i]) continue;
>             if(dpLen[j]+1==dpLen[i]) dpCnt[i]+=dpCnt[j];
>             else if(dpLen[j]+1>dpLen[i]){ /* 出现了更长的递增子序列重新计数 */
>                 dpLen[i]=dpLen[j]+1;
>                 dpCnt[i]=dpCnt[j];
>             }
>         }
>         maxLen=max(maxLen,dpLen[i]);
>     }
>     int res=0;
>     for(int i=0;i<n;++i) if(dpLen[i]==maxLen) res+=dpCnt[i];
>     return res;
> }
> ```

> 删列造序III https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/description/
>
> ```c++
> 
> ```

# 左右数组

> 接雨水 https://leetcode.cn/problems/trapping-rain-water/description/
>
> ```cpp
> int trap(vector<int>& height) {
>     int n=height.size();
>     vector<int> dp_left_max(n+1);
>     auto dp_right_max=dp_left_max;
>     /*
>     	dp_left_max[i]::=[0,i-1] 最大值
>     	dp_right_max[i]::=[i,n) 最大值
>     */
>     
>     /* dp function */
>     for(int i=1;i<=n;++i) dp_left_max[i]=max(height[i-1],dp_left_max[i-1]);
>     for(int i=n-1;i>=0;--i) dp_right_max[i]=max(height[i],dp_right_max[i+1]);
> 
>     int ret=0;
>     for(int i=0;i<n;++i) ret+=max(min(dp_left_max[i],dp_right_max[i+1])-height[i],0);
>     /* 如果本格最高则设置为0,否则会ret会加上一个负数导致结果错误 */
>     return ret;
> }
> ```
>

> 股票 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
>
> ```c++
> int maxProfit(vector<int>& prices) {
>     int n=prices.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]天最便宜的 , g[i]::=[i+1,n)天最贵的 */
>     
>     f[0]=prices[0],g[n-1]=0;
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],prices[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],prices[i+1]);
>     
>     int ret=0;
>     for(int i=0;i<n;++i) ret=max(ret,g[i]-f[i]);
>     return ret;
> }
> ```

> 递增三元子序列 https://leetcode.cn/problems/increasing-triplet-subsequence/description/
>
> ```c++
> bool increasingTriplet(vector<int>& nums) {
>     int n=nums.size();
>     if(n<3) return false;
>     vector<int> f(n),g(n);f[0]=nums[0],g[n-1]=nums[n-1];
>     /* f[i]::=[0,i]最小值,g[i]::=[i,n-1]最大值 */
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],nums[i]);
> 
>     for(int i=1;i<n-1;++i) if(f[i-1]<nums[i] and nums[i]<g[i+1]) return true;
>     /* i左侧最小<[i]<i右侧最大 */
>     return false;
> }
> ```

> 分割数组 https://leetcode.cn/problems/partition-array-into-disjoint-intervals/description/
>
> ```c++
> int partitionDisjoint(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=min(g[i+1],nums[i]);
>     
>     for(int i=0;i<n-1;++i) if(f[i]<=g[i+1]) return i+1;
>     /* 左最大<=右最小即可分割为2个数组 */
>     return -1;
> }
> ```

> 最短无序子数组 https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/
>
> ```c++
> int findUnsortedSubarray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],nums[i]);
> 
>     int left=0,right=n-1;
>     while(left<n){
>         if(f[left]>g[left]) break;
>         ++left;
>     }
>     while(right>-1){
>         if(f[right]>g[right]) break;
>         --right;
>     }
>     if(left<right) return right-left+1; /* 最右失序点-最左失序点+1 */
>     return 0; /* Note:left>=right表示数组是有序的,返回0 */
> }
> ```

> **排序分块** https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/description/
>
> <img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/34fa59deea83729fe1bf868680230c21.jpg" alt="34fa59deea83729fe1bf868680230c21" style="zoom:50%;" />
>
> ```c++
> vector<int> f,g;
> /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
> int ret = 0;
> void dfs(vector<int>& arr, int left, int right) {
>     if (left >= right) { ++ret; return; } /* 长度为1的数组 */
>     
>     for (int i=left; i < right; ++i) {
>         if (f[i] <= g[i + 1]) { 
>             dfs(arr, left, i), dfs(arr, i + 1, right); 
>             return;  /* 对于任意长度大于1的数组,只要存在i下标使得max{[left:i]}<=min{[i+1,right]}即可分块*/
>         }
>     }
>     ++ret; /* 不可分块的数组 */
> }
> int maxChunksToSorted(vector<int>& arr) {
>     int n=arr.size();
>     f.resize(n),g.resize(n);
>     f[0]=arr[0],g[n-1]=arr[n-1];
>     /*dp function*/
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],arr[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],arr[i]);
>     dfs(arr,0,n-1);
>     return ret;
> }
> ```

> 山脉数组 https://leetcode.cn/problems/longest-mountain-in-array/description/
>
> ```c++
> int longestMountain(vector<int>& arr) {
>     int n=arr.size();
>     if(n<3) return 0;
>     vector<int> f(n),g(n);
>     /* 
>         f[i]::=以[i]为结尾的严格递增子数组长度 
>         g[i]::=以[i]为开始的严格递减子数组长度	
>     */
>     
>     f[0]=1,g[n-1]=1;
>     /* dp function */
>     for(int i=1;i<n;++i){
>         if(arr[i]>arr[i-1]) f[i]=1+f[i-1];
>         else f[i]=1;
>     }
>     for(int i=n-2;i>-1;--i){
>         if(arr[i]>arr[i+1]) g[i]=1+g[i+1];
>         else g[i]=1;
>     }
> 
>     int ret=0;
>     for(int i=1;i<n-1;++i){
>         int len=0;
>         if(f[i]>1 and g[i]>1) len=f[i]+g[i]-1; /* Note:不可以峰顶作端点 */
>         if(len>=3) ret=max(ret,len);
>     }
>     return ret;
> }
> ```

> 分组得分 https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/description/
>
> ```c++
> vector<int> maxScoreIndices(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n+1),g(n+1);
>     /* 
>         f[i]::=[0,i) '0'计数 
>         g[i]::=[i,n) '1'计数
>     */
>     
>     //dp function
>     for(int i=1;i<=n;++i){
>         f[i]=f[i-1];
>         if(nums[i-1]==0) ++f[i];
>     }
>     for(int i=n-1;i>-1;--i){
>         g[i]=g[i+1];
>         if(nums[i]==1) ++g[i];
>     }
>     
>     vector<int> ret;
>     int highest=0;
>     for(int i=0;i<=n;++i){
>         if(f[i]+g[i]>highest){
>             highest=f[i]+g[i];
>             ret.clear();
>             ret.push_back(i);
>         }else if(f[i]+g[i]==highest){
>             ret.push_back(i);
>         }
>     }
>     return ret;
> }
> ```

# 最优子数组

> 最大子数组和 https://leetcode.cn/problems/maximum-subarray/description/
>
> ```c++
> int maxSubArray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dp(n);
>     //dp[i]::=以i位置为结尾的最大子数组和
>     
>     dp[0]=nums[0];
>     int ret=dp[0];
>     for(int i=1;i<n;++i){
>         dp[i]=max(dp[i-1]+nums[i],nums[i]); //dp function
>         ret=max(ret,dp[i]);
>     }
>     return ret;
> }
> ```

> 环形最大子数组和 https://leetcode.cn/problems/maximum-sum-circular-subarray/description/
>
> ***环形问题可以考虑逆向转为线性问题***
>
> ```c++
> int maxSubarraySumCircular(vector<int>& nums) {
>     int n=nums.size();
>     int sum=accumulate(nums.begin(),nums.end(),0);
>     vector<int> f(n),g(n); 
>     //f[i]::=以i位置为结尾的最大子数组和
>     //g[i]::=以i位置为结尾的最小子数组和
>     
>     f[0]=g[0]=nums[0];
>     int f_max=f[0],g_min=g[0];
>     for(int i=1;i<n;++i){
>         f[i]=max(f[i-1]+nums[i],nums[i]); //dp function
>         g[i]=min(g[i-1]+nums[i],nums[i]);
>         f_max=max(f_max,f[i]);
>         g_min=min(g_min,g[i]);
>     }
>     
>     if(g_min==sum) return f_max; /* special case */
>     return max(f_max,sum-g_min);
> }
> ```

> 可删一次的最大子数组和 https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/
>
> ```c++
> int maximumSum(vector<int>& arr) {
>     int n=arr.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的最大子数组和(不删除)
>     //g[i]::=以i位置为结尾的最大子数组和(删除任意1个)
>     
>     f[0]=arr[0],g[0]=0;
>     int res=f[0];
>     for(int i=1;i<n;++i){
>         //dp function
>         f[i]=max(arr[i],f[i-1]+arr[i]);
>         g[i]=max(g[i-1]+arr[i],f[i-1]);/* g[i-1]+arr[i]表示删非i位置,f[i-1]表示删i位置 */
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 乘积最大子数组 https://leetcode.cn/problems/maximum-product-subarray/description/
>
> ```c++
> int maxProduct(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的乘积最大
>     //g[i]::=以i位置为结尾的乘积最小
>     
>     f[0]=g[0]=nums[0];
>     int res=nums[0];
>     for(int i=1;i<n;++i){
>         int x=nums[i];
>         //dp function 
>         if(x>=0){
>             f[i]=max(f[i-1]*x,x);
>             g[i]=min(g[i-1]*x,x);
>         }else{
>             f[i]=max(g[i-1]*x,x);
>             g[i]=min(f[i-1]*x,x);
>         }
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 湍流子数组 https://leetcode.cn/problems/longest-turbulent-subarray/description/
>
> ```c++
> int maxTurbulenceSize(vector<int>& arr) {
>     int n=arr.size();
>     if(n==1) return 1;
>     vector<int> f(n); //f[i]::=以i为结尾的湍流子数组长度
>     f[0]=1,f[1]=arr[0]==arr[1]?1:2;
>     int res=max(f[0],f[1]);
>     for(int i=2;i<n;++i){
>         int a=arr[i],b=arr[i-1],c=arr[i-2]; /* 判断可否拼接 */
>         //dp function 
>         if(b>c and b>a or b<c and b<a) f[i]=f[i-1]+1;
>         else f[i]=b==a?1:2;
>         res=max(res,f[i]);
>     }
>     return res;
> }
> ```

# 数组划分

> 分割数组以求最大和 https://leetcode.cn/problems/partition-array-for-maximum-sum/description/
>
> ```c++
> int maxSumAfterPartitioning(vector<int>& arr, int k) {
>     int n=arr.size();
>     vector<int> dp(n+1);
>     /*
>             dp[i]::=拆分数组前i项得到的最大和
>             dp[0]=0凑数(前0项)
>     */
> 
>     for(int i=1;i<=n;++i){
>         int m=arr[i-1];
>         for(int j=1;j<=k and i>=j;++j){
>             m=max(m,arr[i-j]);
>             dp[i]=max(dp[i-j]+m*j,dp[i]); //dp function
>         }
>         /*
>                 m::=arr[i-j,i-1]的最大值
>                 dp[i]=max{dp[i-j]+m*j , ... , dp[i-k]+m*k};
>         */
>     }
>     return dp[n];
> }
> ```

> 填充书架 https://leetcode.cn/problems/filling-bookcase-shelves/
>
> ```c++
> /* 局部最优不可导出全局最优 */
> int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
>     int n=books.size();
>     vector<int> dp(n+1,0x3f3f3f3f);
>     dp[0]=0;
>     /*
>             dp[i]::=前i本书的最小排布高度
>             dp[0]=0 凑数
>     */
> 
>     for(int i=1;i<=n;++i){ /* 等价于分割数组以求最小和 */
>         int h=books[i-1][1];
>         int w=0;
>         for(int j=1;j<=i and books[i-j][0]+w<=shelfWidth;++j){
>             h=max(h,books[i-j][1]);
>             dp[i]=min(dp[i-j]+h,dp[i]); /* 把后几本书放在一排 */
>             w+=books[i-j][0];
>         }
>     }
>     return dp[n];
> }
> ```

> 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/description/
>
> <img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/lQDPKdk1Rf3_lPHNAwzNBP-wY2CU7Wubpq0HebFJMjqqAA_1279_780.jpg" alt="lQDPKdk1Rf3_lPHNAwzNBP-wY2CU7Wubpq0HebFJMjqqAA_1279_780" style="zoom:50%;" />
>
> ```c++
> vector<vector<string>> partition(string s) {
>     int n=s.length();
>     vector<vector<bool>> check(n,vector<bool>(n));
>     for(int i=n-1;i>-1;--i){
>         for(int j=i;j<n;++j){
>             if(s[i]==s[j]){
>                 if(i==j or i+1==j) check[i][j]=true;
>                 else check[i][j]=check[i+1][j-1];
>             }
>         }
>     }
>     vector<vector<vector<string>>> res(n);
>     res[0].push_back({s.substr(0,1)});
>     /* res[i]::= s[0,i]所有分割方案 */
>     for (int i = 1; i < n; ++i) {
>         if(check[0][i]) res[i].push_back({s.substr(0,i+1)}); /* Note */
>         for (int j = 1; j <= i; ++j) {
>             if(check[j][i]){
>                 string sub=s.substr(j,i-j+1);
>                 for(auto item:res[j-1]){
>                     item.push_back(sub);
>                     res[i].push_back(item);
>                 }
>             }
>         }
>     }
>     return res[n - 1];
> }
> ```
>
> 分割回文串2 https://leetcode.cn/problems/palindrome-partitioning-ii/description/
>
> ```c++
> int minCut(string s) {
>  int n=s.length();
>  vector<vector<bool>> check(n,vector<bool>(n));
>  /* check[i][j]::= s[i,j]是否为回文串 */
>  for(int i=n-1;i>-1;--i){
>      for(int j=i;j<n;++j){
>          if(s[i]==s[j]){	/* 首尾相等 */
>              if(i==j or i+1==j) check[i][j]=true; 
>              else check[i][j]=check[i+1][j-1]; /* 检查[i+1,j-1]是否为回文 */
>          }
>      }
>  }
>  vector<int> dp(n,0x3f3f3f3f);
> 	//dp[i] ::= [0,i]子串分割成回文的最小次数
> 
>  for(int i=0;i<n;++i){
>      if(check[0][i]) dp[i]=0; //本身是回文则无需分割
>      else for(int j=0;j<i;++j)
>          if(check[j+1][i]) 	
>              dp[i]=min(dp[i],dp[j]+1);
>  }
>  return dp[n-1];
> }
> ```

> 最低票价 https://leetcode.cn/problems/minimum-cost-for-tickets/description/
>
> ```c++
> int mincostTickets(vector<int>& days, vector<int>& cost) {
>     int n=days.size();
>     vector<int> dp(n);
>     dp[0]=min(cost[0],min(cost[1],cost[2]));
>     for(int i=1;i<n;++i){
>         /* case 1: days[i]在一天票内 */
>         int cost1=dp[i-1]+cost[0];
>         /* case 2: days[i]在七天票内 */
>         int cost2;
>         if(days[i]-days[0]+1<=7) cost2=cost[1];
>         else{
>             for(int j=1;j<=i;++j)
>                 if(days[i]-days[i-j]+1>7){
>                     cost2=dp[i-j]+cost[1];
>                     break; //Note
>                 }
>         }
>         /* case 3: days[i]在30天票内 */
>         int cost3;
>         if(days[i]-days[0]+1<=30) cost3=cost[2];
>         else{
>             for(int j=1;j<=i;++j)
>                 if(days[i]-days[i-j]+1>30){
>                     cost3=dp[i-j]+cost[2];
>                     break;
>                 }
>         }
>         dp[i]=min(cost1,min(cost2,cost3));
>     }
>     return dp[n-1];
> }
> ```

> 单词拆分 https://leetcode.cn/problems/word-break/description/
>
> ```c++
> bool wordBreak(string s, vector<string>& wordDict) {
>     unordered_set<string> dic;
>     for(string& s:wordDict) dic.insert(s);
>     int n=s.length();
>     vector<bool> dp(n);
>     /* dp[i]::=0~i子串可否拼凑 */
>     for(int i=0;i<n;++i){
>         if(dic.count(s.substr(0,i+1))) dp[i]=true;
>         else{
>             for(int j=1;j<=i;++j){
>                 if(dic.count(s.substr(j,i-j+1))) dp[i]=dp[j-1];
>                 if(dp[i]) break; //Note: 第一次变为true后就结束
>             }
>         }
>     }
>     return dp[n-1];
> }
> ```
>
> 单词拆分II https://leetcode.cn/problems/word-break-ii/description/
>
> *同分割回文串*
>
> ```c++
> vector<string> wordBreak(string s, vector<string>& wordDict) {
>     unordered_set<string> dic;
>     for(string& s:wordDict) dic.insert(s);
>     int n=s.length();
>     vector<vector<string>> dp(n); //dp[i]::= 0~i子串可成的句子
>     if(dic.count(s.substr(0,1))) dp[0].push_back(s.substr(0,1));
>     for(int i=1;i<n;++i){
>         if(dic.count(s.substr(0,i+1))) dp[i].push_back(s.substr(0,i+1));
>         for(int j=1;j<=i;++j){
>             if(dic.count(s.substr(j,i-j+1)))
>                 for(string t:dp[j-1]){
>                     t+=' '+s.substr(j,i-j+1);
>                     dp[i].push_back(t);
>                 }
>         }
>     }
>     return dp[n-1];
> }
> ```