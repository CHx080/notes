# 01背包

https://www.nowcoder.com/practice/fd55637d3f24484e96dad9e992d3f62e

> 你有一个背包，最多能容纳的体积是V。
>
> 现在有n个物品，第i个物品的体积为v~i~,价值为w~i~。
>
> （1）求这个背包至多能装多大价值的物品？                        *最大价值*
>
> （2）若背包**恰好装满**，求至多能装多大价值的物品？	*最大体积*

```c++
int biggestValue(vector<int>& v,vector<int>& w,int V){
    int n=v.size();
    auto dp=vector(n+1,vector(V+1,0));
    /*dp(i,j)从前i个物品选取且体积和不超过j的最大价值*/
    for(int i=1;i<=n;++i){
        for(int j=1;j<=V;++j){
            dp[i][j]=dp[i-1][j]; //不选第i个物品
            if(j>=v[i-1]) dp[i][j]=max(dp[i][j],dp[i-1][j-v[i-1]]+w[i-1]); 
            //选第i个物品,选取的第i个物品体积不能超过j
        }
    }
    return dp[n][V];
}
int biggestVolume(vector<int>& v,vector<int>& w,int V){
    int n=v.size();
    auto dp=vector(n+1,vector(V+1,-1));  /* -1表示不存在挑选前i个物品使得体积和为j */
    for(int i=0;i<=n;++i) dp[i][0]=0;
    /*dp(i,j)从前i个物品选取且体积和恰好为j的最大价值,-1表示不合理状态*/
    for(int i=1;i<=n;++i){
        for(int j=1;j<=V;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=v[i-1] and dp[i-1][j-v[i-1]]!=-1)
                dp[i][j]=max(dp[i][j],dp[i-1][j-v[i-1]]+w[i-1]);
        }
    }
    return dp[n][V]==-1?0:dp[n][V];
}
```

# 分割等和子集

https://leetcode.cn/problems/partition-equal-subset-sum/

*转为01背包*

```c++
bool canPartition(vector<int>& nums) {
    int sum=accumulate(nums.begin(),nums.end(),0);
    if(sum%2==1) return false; /* 总和必须是偶数 */
    int n=nums.size();
    auto dp=vector(n+1,vector(sum/2+1,-1));
    /*dp(i,j)从前i个数选取使得和恰好等于j,-1表示无法选取*/
    for(int i=0;i<=n;++i) dp[i][0]=0;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=sum/2;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=nums[i-1] and dp[i-1][j-nums[i-1]]!=-1)
                dp[i][j]=max(dp[i][j],dp[i-1][j-nums[i-1]]+nums[i-1]);
        }
    }
    return dp[n][sum/2]!=-1;
}
```

# 目标和

https://leetcode.cn/problems/target-sum/

```c++
/*
    前⾯加 + 号的数字之和为a，前⾯加 - 号的数字之和为b，整个数组的总和为sum，于是有： 
    ▪ a + b = sum
    ▪ a - b = target
    可得  a = (sum + target)/2  
    也就是说仅需在  nums  数组中选择⼀些数，将它们凑成和为(sum + target)/2
*/
int findTargetSumWays(vector<int>& nums, int target) {
    int sum=accumulate(nums.begin(),nums.end(),0);
    int n=nums.size(),m=(sum+target)/2;
    if(m<0 or (sum+target)%2) return 0;
    auto dp=vector(n+1,vector(m+1,0));
    dp[0][0]=1;  
    /*
    	dp[i][0]=1;for(int j=1;...)是错误的
    	m=0时第一列还需要更新
    */
    for(int i=1;i<=n;++i){
        for(int j=0;j<=m;++j){
            dp[i][j]=dp[i-1][j];
            if(j>=nums[i-1]) dp[i][j]+=dp[i-1][j-nums[i-1]];
        }
    }
    for(int i=0;i<=n;++i) cout<<dp[i][0]<<endl;
    return dp[n][m];
}
```

# 最后⼀块⽯头的重量II  

https://leetcode.cn/problems/last-stone-weight-ii/

```c++
/*
将石头平均分成2部分，只要从中挑选出重量之和最接近的sum/2
01背包问题，将石头的重量当作价值和体积
dp[i][j]表示从前i个石头中挑选使得和不超过j的最大值
*/
int lastStoneWeightII(vector<int>& stones) {
    int n=stones.size();
    int sum=accumulate(stones.begin(),stones.end(),0);
    int target=sum/2;
    vector<vector<int>> dp(n+1,vector<int>(target+1));
    for(int i=1;i<=n;++i){
        for(int j=0;j<=target;++j){
            dp[i][j]=dp[i-1][j]; //不选第i块石头
            if(j>=stones[i-1]) dp[i][j]=max(dp[i-1][j-stones[i-1]]+stones[i-1],dp[i][j]);
        }
    }
    return sum-2*dp[n][target];
}

int lastStoneWeightII(vector<int>& stones) {  //优化版本
    int n=stones.size();
    int sum=accumulate(stones.begin(),stones.end(),0);
    int target=sum/2;
    vector<int> dp(target+1);
    for(int i=1;i<=n;++i){
        for(int j=target;j>=stones[i-1];--j){
            dp[j]=max(dp[j-stones[i-1]]+stones[i-1],dp[j]);
        }
    }
    return sum-2*dp[target];
}
```

