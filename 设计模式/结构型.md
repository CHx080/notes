# 适配器

适配器模式将原本不兼容的接口粘合在一起，实现不兼容接口之间的合作。本质上适配器是一层目的为统一对外接口的封装。适配器分为**类适配器**和**对象适配器**，类适配器基于多继承，对象适配器基于组合。

***适配器所配接的2个对象是没有依赖关系的，这是与代理模式最大的不同，代理模式中代理者必须依赖被代理对象***

**UML:**

![image-20250205205948340](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205205948340.png)

```c++
class Target{
public:
    virutal void funcA()=0;
};
class Adaptee{
public:
    virtual void funcC()=0;
};
class Adapter : public Target,public Adaptee{ /*类适配器*/
public:
    void funcA override(){funcC();}
};
class Adapter : public Target{				/*对象适配器*/
	Adaptee* adaptee;
public:
    void funcA override(){adaptee->funcC();}
};
```

*适配器模式少使用*

# 代理※

代理模式为某个对象提供一种中介代理，用于实现这个对象的访问。被代理的对象不适合或者不能直接引用。代理者依赖被代理对象。代理模式可以细分为**保护代理、虚拟代理、远程代理、缓存代理**

**代理者和被代理对象具有相同的基类**

**UML:**

![image-20250205212512114](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205212512114.png)

```c++
class Subject{
public:
    virtual void func()=0;
}
class RealSubject{
public:
    void func() override{}
};
class Proxy : public Subject{
	RealSubject* real;
public:
    void func() override{
        /*访问控制*/
        /*合法则转发*/ real->func();
        /*不合法不转发*/
    }
};
```

# 桥接

桥接模式利用**可分离聚合关系**代替继承关系，实现类之间的弱关联。避免了多个继承带来的类臃肿。**程序运行时动态决定类之间的关系**。如果设计到多继承时，可以考虑用组合的思想代替继承。

**UML:**

![image-20250206121714535](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250206121714535.png)

```c++
class Color {
public:
	virtual void showColor() = 0;
};
class White : public Color {
public:
	void showColor() override{ cout << "white "; }
};
class Black : public Color {
public:
	void showColor() override { cout << "black "; }
};
class Shape {
protected:
	Color* color;
public:
	virtual void showShape() = 0;
	Shape(Color* color):color(color){}
};
class Rec : public Shape{
public:
	void showShape() override { color->showColor(); cout << "rec"; }
	Rec(Color* color):Shape(color){}
};
class Squ : public Shape {
public:
	void showShape() override { color->showColor(); cout << "squ"; }
	Squ(Color* color) :Shape(color) {}
};
/*
多继承的耦合度较高，适合用组合(桥接模式)代替
相比于class WhiteRec:public Color,public Shape这种做法
桥接模式更好，既没有增加新的类，降低与基类的耦合度
Color基类中针对非showColor()的修改都不会影响桥接产生的对象
*/
```

# 装饰

装饰模式在不修改原始类的前提下，客户端课可以直接动态修改或包装已存在的对象以达到**对原有对象属性与方法的扩展**。代码最直接的体现是**相同接口的嵌套调用**

**UML:**

![image-20250206130704785](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250206130704785.png)

```c++
class Beverage {
public:
	virtual float cost() = 0;
};
class Cola : public Beverage{
public:
	float cost() override { return 3.0f; }
};
class Decorator : public Beverage{
protected:
	Beverage* core;
};
class NoSugarCola : public Decorator {
public:
	float cost() override { return 2.0f + core->cost(); }
};
```

# 外观

外观模式将复杂的接口进行再次封装，不关心接口的具体实现，只关心接口的调用顺序和逻辑，从而对外提供一个再次封装后的外观接口。子系统对外隐藏了它的复杂性，简化了客户端访问子系统的流程。

**外观模式仅仅封装了子系统的接口，并未对整个子系统进行封装，客户端可以绕过外观对象提供的统一接口直接访问子系统。**

**UML:**

![image-20250206122308019](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250206122308019.png)

```c++
class StreamPlayer{
public:
    void play();
    void pause();
};
class Tuner{
public:
    void on();
    void off();
};
class Screen{
public:
    void up();
    void down();
};
class Light{
public:
    void bright();
    void dim();
};

class TheaterFacade{
public:
    void beginMovie(){
        stream->play();tuner->on();screen->up();light->bright();
    }
    void endMovie(){
        stream->pause();tuner->off();screen->down();light->dim();
    }
private:
    StreamPlayer* stream;
    Tuner* tuner;
    Screen* screen;
    Light* light;
};
```

# 享元

享元模式通过对象池实现对一个对象的多次服用，大大减少了对象的创建，从而避免创建所带来的内存消耗。

**UML：**

![image-20250206131308763](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250206131308763.png)

```c++
class SharedObject {};
class Object1 : public SharedObject{};
class Object2 : public SharedObject{};
class Object3 : public SharedObject{};
class SharedFactory {
private:
	map<string, vector<SharedObject*>> pool;
public:
	SharedObject* getObject(string type){
		/*有余量则返回，没余量则申请*/
		/*注意线程安全*/
	}
};
```

# 组合

组合模式将对象组合成树形结构来表现**部分-整体**层次结构,让客户可以**统一看待个别对象和对象组合**。

组合模式的基本单位是组件
组件可以分为叶子和组合

组合模式存在继承缺陷**(基类与派生类的强耦合性不可避免,派生类会继承不需要的接口)**，需要根据实际情况权衡透明和安全。

**UML:**

![image-20250206124411228](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250206124411228.png)

```c++
class Component{
public:
    virtual void print()=0;
    virtual void addComponent(Component* com){}; //这个方法对叶子是没有意义的
};
class Leaf:public Component{
public:
    void print() override{ cout<<"Leaf"; }
};
class Composite:public Component{
public:
    void addComponent(Component* com) override{childs.push_back(com);}
    void print() override{ for(auto item:childs) item->print(); }
private:
    vector<Component*> childs;
};
```

