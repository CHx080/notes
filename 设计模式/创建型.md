# 单例※

单例对象全局仅存在一份，用户每一次获取到的对象的地址均是相同的。即被设置成单例的类其实例对象只会被构造一次，内存开销非常小。

**UML:**

![image-20250129152109584](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250129152109584.png)

**懒汉单例**：程序启动即初始化

```c++
class SingleObject{
private:
    SingleObject(){}   //构造函数私有化，使外部无法实例化
public:
    static SingleObject* getInstance(){ return self; }  //单例类必须设置一个获取单例对象的方法
    SingleObject(const SingleObject&)=delete;
    const SingleObject& operator=(const SingleObject&)=delete;
private:
    static SingleObject* self;
};
SingleObject* SingleObject::self=new SingleObject;
```

-------

**饿汉单例**：用时初始化

```c++
class SingleObject{
private:
    SingleObject(){}
public:
    static SingleObject* getInstance(){
        static SingleObject* self=new SingleObject;
        return self;//C++11后static对象实例化线程安全
    }
    SingleObject(const SingleObject&)=delete;
    const SingleObject& operator=(const SingleObject&)=delete;
};
```

# 原型

通过已存在的对象复制出新的对象，新的对象初始值完全等同于被复制的对象，可以通过设置接口进行细节调整。

> **原型模式和拷贝构造的不同：**拷贝构造属于构造函数，构造函数不能被声明为虚函数，即构造函数无法实现多态。如果用户通过拷贝构造进行对象复制，那么就必须依赖派生类而非基类。原型模式要求在基类中声明clone虚方法，由派生类进行重写clone方法，用户可以通过基类的clone方法实现动态类型的派生类拷贝，符合**依赖抽象**原则。

**UML:**

![image-20250205111831279](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205111831279.png)

```c++
class PrototypeComputer {
public:
    virtual PrototypeComputer* clone() = 0;
        /* setCpu,setGpu,... 复制骨架后细节的调整*/
};
class Computer : public PrototypeComputer {
public:
    Computer(string cpu, string gpu, string memory, string disk, string keyboard, string mouse)
        : cpu(cpu), gpu(gpu), memory(memory), disk(disk), keyboard(keyboard), mouse(mouse){}
    PrototypeComputer* clone() override { return new Computer(*this); }
private:
    string cpu,gpu,memory,disk,keyboard,mouse;
};
/*clone方法足够简单，避免重复的传参构造*/
```

# 工厂方法※

**产品与工厂一一对应**。实现对象创建和使用的松耦合，由**工厂统一管理对象的构造**，用户只需要知道工厂对其提供的接口即可。工厂等价于在用户和产品之间的中间层。如果产品构造函数发生改变，只需要修改工厂，由于**工厂的代码是集中的**，修改较方便。零散的用户使用部分代码无需任何修改。

**UML:**

![image-20250205113046668](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205113046668.png)

```c++
class Product {
public:
	virtual void show() = 0;
};
class Phone : public Product {
public:
	void show() override{}
};
class TV : public Product {
public:
	void show() override{}
};
class Factory {
public:
	virtual Product* doProduct() = 0;
};
class PhoneFactory : public Factory{
public:
	Product* doProduct() override { return new Phone; }
};
class TVFactory : public Factory {
public:
	Product* doProduct() override { return new TV; }
};
```

# 抽象工厂

**产品与工厂多对一**，一个工厂负责生成一个**产品组**。工厂方法是特殊的抽象工厂。相较于工厂方法所需要的类更少，但是增加了耦合度，新增一个产品就需要修改所有的工厂。

*新增一个ProductC，那么Factory中就需要新增doProduct接口，从而影响到所有派生类*

**UML:**

![image-20250205122632725](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205122632725.png)

```c++
class ProductA {
public:
	virtual void show() = 0;
};
class ConcreteA1 : public ProductA {
public:
	void show() override{}
};
class ConcreteA2 : public ProductA {
public:
	void show() override{}
};
class ProductB {
public:
	virtual void show() = 0;
};
class ConcreteB1 : public ProductB {
public:
	void show() override {}
};
class ConcreteB2 : public ProductB {
public:
	void show() override {}
};
class Factory {
public:
	virtual ProductA* doProductA() = 0;
	virtual ProductB* doProductB() = 0;
};
class OneFactory : public Factory {
public:
	ProductA* doProductA() override { return new ConcreteA1; }
	ProductB* doProductB() override { return new ConcreteB1; }
};
class TwoFactory : public Factory {
public:
	ProductA* doProductA() override { return new ConcreteA2; }
	ProductB* doProductB() override { return new ConcreteB2; }
};
```

# 简单工厂※

不依赖基类，实现简单，**违背开闭原则**

![image-20250205123311801](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205123311801.png)

```c++
enum PhoneType {
	ManPhone,
	WomanPhone,
	ChildPhone
};
class Phone {};
class PhoneMan : public Phone{};
class PhoneWoman : public Phone{};
class PhoneChild : public Phone{};
class PhoneFactory {
public:
	Phone* doPhone(PhoneType type) {
		switch (type) {
		case ManPhone: return new PhoneMan;
		case WomanPhone: return new PhoneWoman;
		case ChildPhone: return new PhoneChild;
		}
	}
};
```

# 建造者

对于一个复杂对象的构造，将构造过程拆解为各小步骤。各步骤的实现由特定的方法完成，实现构造过程和对象创建本身解耦。

**UML:**

![image-20250205124721778](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250205124721778.png)

```c++
//省略了抽象产品
class People {
public:
	void setHead(){}
	void setBody(){}
	void setHand(){}
	void setFeet(){}
private:
	string head, body, hand, feet;
};
class BuildPeople {
public:
	virtual void buildHead() = 0;
	virtual void buildBody() = 0;
	virtual void buildHand() = 0;
	virtual void buildFeet() = 0;
	People* getPeople() { return people; }
protected:
	People* people = new People;
};
class ConcreteBuildPeople : public BuildPeople {
public:
	void buildHead() override {}
	void buildBody() override {}
	void buildHand() override {}
	void buildFeet() override {}
};
class Director {
public:
	People* construct() {
		builder->buildHead();
		builder->buildBody();
		builder->buildHand();
		builder->buildFeet();
        /*4步构造展开往往是一段非常长的逻辑,将每一步构造委派给特定方法完成可以快速定位bug*/
		return builder->getPeople();
	}
private:
	BuildPeople* builder = new ConcreteBuildPeople;
};
```

*指挥者一般不会显示设置，construct方法可以集成在建造者中*
