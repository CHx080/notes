---

# 二叉树深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/

```c++
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    int leftDepth=maxDepth(root->left);
    int rightDepth=maxDepth(root->right);
    return max(leftDepth,rightDepth)+1;
}
```

# 二叉树最小深度

https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/

```c++
int minDepth(TreeNode* root) {
    if(!root) return 0;
    if(!root->left) return minDepth(root->right)+1;
    else if(!root->right) return minDepth(root->left)+1;
    else return min(minDepth(root->left),minDepth(root->right))+1;
}
```

# 平衡树判断

https://leetcode.cn/problems/balanced-binary-tree/description/

```c++
bool isBalanced(TreeNode* root) {
    if(!root) return true;
    int leftTreeDepth=maxDepth(root->left);
    int rightTreeDepth=maxDepth(root->right);
    if(abs(leftTreeDepth-rightTreeDepth)>1) return false;
    return isBalanced(root->left)&&isBalanced(root->right);
}
```

# 二叉树直径

https://leetcode.cn/problems/diameter-of-binary-tree/

```c++
unordered_map<TreeNode*,int> depth; /*记忆化搜索——剪枝,避免重复地高度计算*/
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    if(depth.count(root)) return depth[root];
    int leftDepth=maxDepth(root->left);
    int rightDepth=maxDepth(root->right);
    int temp=max(leftDepth,rightDepth)+1;
    depth[root]=temp;
    return temp;
}
/* 左子树最长路径+右子树最长路径=经过某节点的直径 */
int res=0;
void _diameterOfBinaryTree(TreeNode* root) {
    if(!root->left and !root->right) return;
    int leftDia=maxDepth(root->left);
    int rightDia=maxDepth(root->right);
    res=max(res,leftDia+rightDia);
    if(root->left) _diameterOfBinaryTree(root->left);
    if(root->right) _diameterOfBinaryTree(root->right);
}
int diameterOfBinaryTree(TreeNode* root) {
    _diameterOfBinaryTree(root);
    return res;
}
```

# 最长同值路径

https://leetcode.cn/problems/longest-univalue-path/

```c++
int res=0;
int _longestUnivaluePath(TreeNode* root){
    if(!root->left and !root->right) return 0;
    int leftPath=0,rightPath=0;//左右子树的同值路径
    int len=0;//当前节点的同值路径
    int ret=0;//左右较长的同值路径
    if(root->left) {
        leftPath=_longestUnivaluePath(root->left);
        if(root->left->val==root->val) {len+=leftPath+1;ret=len;}
    }
    if(root->right) {
        rightPath=_longestUnivaluePath(root->right);
        if(root->right->val==root->val) {len+=rightPath+1;ret=max(ret,rightPath+1);}
    }
    res=max(res,len);
    return ret;
}
int longestUnivaluePath(TreeNode* root) {
    if(!root) return 0;
    _longestUnivaluePath(root);
    return res;
}
```

# 最大路径和

https://leetcode.cn/problems/binary-tree-maximum-path-sum/

```c++
/*
    关联当前节点的最大路径和,若已知左侧最大路径和为L,右侧最大路径和为R
    左右侧均为正数则都取,仅一个为正数则取正的,都为非正数则不取,取值记为X
    记V为当前节点值,使用X+V更新全局结果
*/
int res=INT_MIN;
int _maxPathSum(TreeNode* root){
    if(!root) return 0;
    int L=_maxPathSum(root->left);
    int R=_maxPathSum(root->right);
    int X=max({L+R,L,R,0}),V=root->val;
    res=max(res,X+V);
    return V+max({L,R,0});
}
int maxPathSum(TreeNode* root) {
    _maxPathSum(root);
    return res;
}
```

----

----

----

# 分配硬币

https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/

```c++

```

# 频次最高的子树元素和

https://leetcode.cn/problems/most-frequent-subtree-sum/description/

```c++

```

# 打家劫舍III

https://leetcode.cn/problems/house-robber-iii/description/

```c++

```

# 监控二叉树

https://leetcode.cn/problems/binary-tree-cameras/description/

```c++

```

