# 普通子序列

> 严格递增子序列长度 https://leetcode.cn/problems/longest-increasing-subsequence/description/
>
> ```c++
> int lengthOfLIS(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dp(n,1);
>     /* dp[i]::= 以i为结尾的严格递增子序列长度 */
>     int res=1;
>     for(int i=1;i<n;++i){
>         for(int j=i-1;j>-1;--j)
>             if(nums[j]<nums[i]) dp[i]=max(dp[i],dp[j]+1); //保证右端最大
>         res=max(res,dp[i]);
>     }
>     return res;
> }
> ```

> 严格递增子序列个数 https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/
>
> ```c++
> int findNumberOfLIS(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dpLen(n),dpCnt(n);
>     /* (以i结尾的...)
>     	dpLen表长度
>     	dpCnt表个数
>     */
>     int maxLen=0;
>     for(int i=0;i<n;++i){
>         dpLen[i]=dpCnt[i]=1;
>         for(int j=0;j<i;++j){
>             if(nums[j]>=nums[i]) continue;
>             if(dpLen[j]+1==dpLen[i]) dpCnt[i]+=dpCnt[j];
>             else if(dpLen[j]+1>dpLen[i]){ /* 出现了更长的递增子序列重新计数 */
>                 dpLen[i]=dpLen[j]+1;
>                 dpCnt[i]=dpCnt[j];
>             }
>         }
>         maxLen=max(maxLen,dpLen[i]);
>     }
>     int res=0;
>     for(int i=0;i<n;++i) if(dpLen[i]==maxLen) res+=dpCnt[i];
>     return res;
> }
> ```

> 删列造序III https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/description/
>
> ![img](https://pic.leetcode.cn/1737944353-adxVQB-lQDPJxPxwEcFgInNAe7NBP-w97Yjjb97G0EHevqbgXAiAA_1279_494.jpg)
>
> ```c++
> bool isValid(vector<string>& strs,int i,int j){
>     for(string& s:strs){
>         if(s[j]>s[i]) return false;
>     }
>     return true;
> }
> int minDeletionSize(vector<string>& strs) {
>     int n=strs[0].size();	//n是矩阵列数
>     int maxLen=0;
>     vector<int> dp(n,1);
>     for(int i=0;i<n;++i){
>         for(int j=0;j<i;++j){
>             if(isValid(strs,i,j)) dp[i]=max(dp[j]+1,dp[i]);
>         }
>         maxLen=max(maxLen,dp[i]);
>     }
>     return n-maxLen;
> }
> ```

> 最长定差子序列 https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/
>
> ```c++
> int longestSubsequence(vector<int>& arr, int dif) { /* 超时! */
>     int n=arr.size();
>     int res=0;
>     vector<int> dp(n,1); /* dp[i]::=以下标i位置为结尾的最长定差序列长度 */
>     for(int i=0;i<n;++i){
>         for(int j=0;j<i;++j){
>             if(arr[i]-arr[j]==dif) dp[i]=max(dp[i],dp[j]+1);
>         }
>         res=max(res,dp[i]);
>     }
>     return res;
> }
> ```
>
> ```c++
> int longestSubsequence(vector<int>& arr, int dif) {
>     int n=arr.size();
>     int res=0;
>     unordered_map<int,int> hash; /* hash[arr[i]]::=以arr[i]为结尾的最长定差序列长度 */
>     for(int i=0;i<n;++i){
>         if(hash.count(arr[i]-dif)) hash[arr[i]]=hash[arr[i]-dif]+1;
>         else hash[arr[i]]=1;
>         res=max(res,hash[arr[i]]);
>     }
>     return res;
> }
> ```

> 摆动序列 https://leetcode.cn/problems/wiggle-subsequence/description/
>
> ```c++
> int wiggleMaxLength(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n,1),g(n,1);
>     /*
>             f[i]::=以i位置为结尾的最长摆动序列长度 且 序列末项>序列次末项
>             g[i]::=         ......              且 序列末项<序列次末项
>         */
>     int res=0;
>     for(int i=0;i<n;++i){
>         for(int j=0;j<i;++j){
>             if(nums[j]<nums[i]) f[i]=max(f[i],g[j]+1);
>             if(nums[j]>nums[i]) g[i]=max(g[i],f[j]+1);
>         }
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 区间覆盖-灌溉花园 https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/
>
> ```c++
> /* 区间覆盖问题 */
> int minTaps(int n, vector<int>& r) {
>     int res=0x3f3f3f3f;
>     vector<int> dp(n+1,0x3f3f3f3f);
>     /* dp[i]::=灌溉到0~i+r[i]所需要的最少水龙头数目 */
>     for(int i=0;i<=n;++i){
>         if(i-r[i]<=0) dp[i]=1;
>         else{
>             for(int j=0;j<i;++j)
>                 if(j+r[j]>=i-r[i])
>                     dp[i]=min(dp[j]+1,dp[i]);
>         }
>         if(i+r[i]>=n) res=min(res,dp[i]);
>     }
>     return res==0x3f3f3f3f?-1:res;
> }
> ```
## 子集

子集和子序列最大的不同在于子集是无序的，可依据情景作**预排序**处理

> 最大整除子集 https://leetcode.cn/problems/largest-divisible-subset/description/
>
> ```c++
> vector<int> largestDivisibleSubset(vector<int>& nums) {
>     sort(nums.begin(),nums.end()); //Note
>     int n=nums.size();
>     vector<vector<int>> dp(n);
>     int idx=0;
>     /* dp[i]::=以i下标为结尾的最大整除子集 */
>     for(int i=0;i<n;++i){
>         vector<int> temp;
>         for(int j=0;j<i;++j){
>             if(nums[i]%nums[j]==0) /* nums[j]其最大整除子集中的最大数,nums[i]>=nums[j]恒成立 */
>                 if(dp[j].size()>temp.size())
>                     temp=dp[j];
>         }
>         temp.push_back(nums[i]);
>         dp[i]=temp;
>         if(dp[idx].size()<=dp[i].size()) idx=i;
>     }
>     return dp[idx];
> }
> ```

> 最长数对链 https://leetcode.cn/problems/maximum-length-of-pair-chain/description/
>
> ```c++
> int findLongestChain(vector<vector<int>>& pairs) {
>     sort(pairs.begin(),pairs.end());
>     int n=pairs.size();
>     vector<int> dp(n,1); 
>     int res=0;
>     /* dp[i]::=以i数对为结尾数对链长度 */
>     for(int i=0;i<n;++i){
>         for(int j=0;j<i;++j)
>             if(pairs[i][0]>pairs[j][1])
>                 dp[i]=max(dp[i],dp[j]+1);
>         res=max(res,dp[i]);
>     }
>     return res;
> }
> ```

> 最长字符串链 https://leetcode.cn/problems/longest-string-chain/description/
>
> ```c++
> bool isValid(string& s1,string& s2){
>     int n1=s1.length(),n2=s2.length();
>     if(n1!=n2+1) return false;
>     int i=0,j=0;bool skip=false;
>     while(i<n1 and j<n2){
>         if(s1[i]==s2[j]) {++i,++j;}
>         else{
>             if(skip) return false;
>             ++i;skip=true;
>         }
>     }
>     return true;
> }
> int longestStrChain(vector<string>& words) {
>     sort(words.begin(),words.end(),[](string& s1,string& s2)->bool{
>         return s1.length()<s2.length();});
>     int n=words.size();
>     vector<int> dp(n,1);
>     int res=0;
>     /* dp[i]::=以i下标为结尾的最长字符串链 */
>     for(int i=0;i<n;++i){
>         for(int j=0;j<i;++j)
>             if(isValid(words[i],words[j]))
>                 dp[i]=max(dp[i],dp[j]+1);
>         res=max(res,dp[i]);
>     }
>     return res;
> }
> ```

> 区间覆盖-视频拼接 https://leetcode.cn/problems/video-stitching/description/
>
> ***和灌溉花园类似,多了一个预排序***
>
> ```c++
> int videoStitching(vector<vector<int>>& clips, int time) {
>     sort(clips.begin(),clips.end());
>     int n=clips.size();
>     vector<int> dp(n,0x3f3f3f3f);
>     //dp[i]::=拼出视频0~clips[i][1]所需要的片段数
>     int cnt=0x3f3f3f3f;
>     for(int i=0;i<n;++i){
>         if(clips[i][0]==0) dp[i]=1;
>         else{
>             for(int j=0;j<i;++j)
>                 if(clips[j][1]>=clips[i][0])
>                     dp[i]=min(dp[i],dp[j]+1);
>         }
>         if(clips[i][1]>=time) cnt=min(cnt,dp[i]);
>         //可能dp[i]==0x3f3f3f3f,但不影响结果
>     }
>     return cnt==0x3f3f3f3f?-1:cnt;
> }
> ```
# 左右数组

> 接雨水 https://leetcode.cn/problems/trapping-rain-water/description/
>
> ```cpp
> int trap(vector<int>& height) {
>     int n=height.size();
>     vector<int> dp_left_max(n+1);
>     auto dp_right_max=dp_left_max;
>     /*
>     	dp_left_max[i]::=[0,i-1] 最大值
>     	dp_right_max[i]::=[i,n) 最大值
>     */
>     
>     /* dp function */
>     for(int i=1;i<=n;++i) dp_left_max[i]=max(height[i-1],dp_left_max[i-1]);
>     for(int i=n-1;i>=0;--i) dp_right_max[i]=max(height[i],dp_right_max[i+1]);
> 
>     int ret=0;
>     for(int i=0;i<n;++i) ret+=max(min(dp_left_max[i],dp_right_max[i+1])-height[i],0);
>     /* 如果本格最高则设置为0,否则会ret会加上一个负数导致结果错误 */
>     return ret;
> }
> ```
>

> 股票 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
>
> ```c++
> int maxProfit(vector<int>& prices) {
>     int n=prices.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]天最便宜的 , g[i]::=[i+1,n)天最贵的 */
>     
>     f[0]=prices[0],g[n-1]=0;
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],prices[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],prices[i+1]);
>     
>     int ret=0;
>     for(int i=0;i<n;++i) ret=max(ret,g[i]-f[i]);
>     return ret;
> }
> ```

> 递增三元子序列 https://leetcode.cn/problems/increasing-triplet-subsequence/description/
>
> ```c++
> bool increasingTriplet(vector<int>& nums) {
>     int n=nums.size();
>     if(n<3) return false;
>     vector<int> f(n),g(n);f[0]=nums[0],g[n-1]=nums[n-1];
>     /* f[i]::=[0,i]最小值,g[i]::=[i,n-1]最大值 */
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],nums[i]);
> 
>     for(int i=1;i<n-1;++i) if(f[i-1]<nums[i] and nums[i]<g[i+1]) return true;
>     /* i左侧最小<[i]<i右侧最大 */
>     return false;
> }
> ```

> 分割数组 https://leetcode.cn/problems/partition-array-into-disjoint-intervals/description/
>
> ```c++
> int partitionDisjoint(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=min(g[i+1],nums[i]);
>     
>     for(int i=0;i<n-1;++i) if(f[i]<=g[i+1]) return i+1;
>     /* 左最大<=右最小即可分割为2个数组 */
>     return -1;
> }
> ```

> 最短无序子数组 https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/
>
> ```c++
> int findUnsortedSubarray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],nums[i]);
> 
>     int left=0,right=n-1;
>     while(left<n){
>         if(f[left]>g[left]) break;
>         ++left;
>     }
>     while(right>-1){
>         if(f[right]>g[right]) break;
>         --right;
>     }
>     if(left<right) return right-left+1; /* 最右失序点-最左失序点+1 */
>     return 0; /* Note:left>=right表示数组是有序的,返回0 */
> }
> ```

> **排序分块** https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/description/
>
> <img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/34fa59deea83729fe1bf868680230c21.jpg" alt="34fa59deea83729fe1bf868680230c21" style="zoom:50%;" />
>
> ```c++
> vector<int> f,g;
> /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
> int ret = 0;
> void dfs(vector<int>& arr, int left, int right) {
>     if (left >= right) { ++ret; return; } /* 长度为1的数组 */
>     
>     for (int i=left; i < right; ++i) {
>         if (f[i] <= g[i + 1]) { 
>             dfs(arr, left, i), dfs(arr, i + 1, right); 
>             return;  /* 对于任意长度大于1的数组,只要存在i下标使得max{[left:i]}<=min{[i+1,right]}即可分块*/
>         }
>     }
>     ++ret; /* 不可分块的数组 */
> }
> int maxChunksToSorted(vector<int>& arr) {
>     int n=arr.size();
>     f.resize(n),g.resize(n);
>     f[0]=arr[0],g[n-1]=arr[n-1];
>     /*dp function*/
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],arr[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],arr[i]);
>     dfs(arr,0,n-1);
>     return ret;
> }
> ```

> 山脉数组 https://leetcode.cn/problems/longest-mountain-in-array/description/
>
> ```c++
> int longestMountain(vector<int>& arr) {
>     int n=arr.size();
>     if(n<3) return 0;
>     vector<int> f(n),g(n);
>     /* 
>         f[i]::=以[i]为结尾的严格递增子数组长度 
>         g[i]::=以[i]为开始的严格递减子数组长度	
>     */
>     
>     f[0]=1,g[n-1]=1;
>     /* dp function */
>     for(int i=1;i<n;++i){
>         if(arr[i]>arr[i-1]) f[i]=1+f[i-1];
>         else f[i]=1;
>     }
>     for(int i=n-2;i>-1;--i){
>         if(arr[i]>arr[i+1]) g[i]=1+g[i+1];
>         else g[i]=1;
>     }
> 
>     int ret=0;
>     for(int i=1;i<n-1;++i){
>         int len=0;
>         if(f[i]>1 and g[i]>1) len=f[i]+g[i]-1; /* Note:不可以峰顶作端点 */
>         if(len>=3) ret=max(ret,len);
>     }
>     return ret;
> }
> ```

> 分组得分 https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/description/
>
> ```c++
> vector<int> maxScoreIndices(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n+1),g(n+1);
>     /* 
>         f[i]::=[0,i) '0'计数 
>         g[i]::=[i,n) '1'计数
>     */
>     
>     //dp function
>     for(int i=1;i<=n;++i){
>         f[i]=f[i-1];
>         if(nums[i-1]==0) ++f[i];
>     }
>     for(int i=n-1;i>-1;--i){
>         g[i]=g[i+1];
>         if(nums[i]==1) ++g[i];
>     }
>     
>     vector<int> ret;
>     int highest=0;
>     for(int i=0;i<=n;++i){
>         if(f[i]+g[i]>highest){
>             highest=f[i]+g[i];
>             ret.clear();
>             ret.push_back(i);
>         }else if(f[i]+g[i]==highest){
>             ret.push_back(i);
>         }
>     }
>     return ret;
> }
> ```

# 最优子数组

> 最大子数组和 https://leetcode.cn/problems/maximum-subarray/description/
>
> ```c++
> int maxSubArray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dp(n);
>     //dp[i]::=以i位置为结尾的最大子数组和
>     
>     dp[0]=nums[0];
>     int ret=dp[0];
>     for(int i=1;i<n;++i){
>         dp[i]=max(dp[i-1]+nums[i],nums[i]); //dp function
>         ret=max(ret,dp[i]);
>     }
>     return ret;
> }
> ```

> 环形最大子数组和 https://leetcode.cn/problems/maximum-sum-circular-subarray/description/
>
> ***环形问题可以考虑逆向转为线性问题***
>
> ```c++
> int maxSubarraySumCircular(vector<int>& nums) {
>     int n=nums.size();
>     int sum=accumulate(nums.begin(),nums.end(),0);
>     vector<int> f(n),g(n); 
>     //f[i]::=以i位置为结尾的最大子数组和
>     //g[i]::=以i位置为结尾的最小子数组和
>     
>     f[0]=g[0]=nums[0];
>     int f_max=f[0],g_min=g[0];
>     for(int i=1;i<n;++i){
>         f[i]=max(f[i-1]+nums[i],nums[i]); //dp function
>         g[i]=min(g[i-1]+nums[i],nums[i]);
>         f_max=max(f_max,f[i]);
>         g_min=min(g_min,g[i]);
>     }
>     
>     if(g_min==sum) return f_max; /* special case */
>     return max(f_max,sum-g_min);
> }
> ```

> 可删一次的最大子数组和 https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/
>
> ```c++
> int maximumSum(vector<int>& arr) {
>     int n=arr.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的最大子数组和(不删除)
>     //g[i]::=以i位置为结尾的最大子数组和(删除任意1个)
>     
>     f[0]=arr[0],g[0]=0;
>     int res=f[0];
>     for(int i=1;i<n;++i){
>         //dp function
>         f[i]=max(arr[i],f[i-1]+arr[i]);
>         g[i]=max(g[i-1]+arr[i],f[i-1]);/* g[i-1]+arr[i]表示删非i位置,f[i-1]表示删i位置 */
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 乘积最大子数组 https://leetcode.cn/problems/maximum-product-subarray/description/
>
> ```c++
> int maxProduct(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的乘积最大
>     //g[i]::=以i位置为结尾的乘积最小
>     
>     f[0]=g[0]=nums[0];
>     int res=nums[0];
>     for(int i=1;i<n;++i){
>         int x=nums[i];
>         //dp function 
>         if(x>=0){
>             f[i]=max(f[i-1]*x,x);
>             g[i]=min(g[i-1]*x,x);
>         }else{
>             f[i]=max(g[i-1]*x,x);
>             g[i]=min(f[i-1]*x,x);
>         }
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 湍流子数组 https://leetcode.cn/problems/longest-turbulent-subarray/description/
>
> ```c++
> int maxTurbulenceSize(vector<int>& arr) {
>     int n=arr.size();
>     if(n==1) return 1;
>     vector<int> f(n); //f[i]::=以i为结尾的湍流子数组长度
>     f[0]=1,f[1]=arr[0]==arr[1]?1:2;
>     int res=max(f[0],f[1]);
>     for(int i=2;i<n;++i){
>         int a=arr[i],b=arr[i-1],c=arr[i-2]; /* 判断可否拼接 */
>         //dp function 
>         if(b>c and b>a or b<c and b<a) f[i]=f[i-1]+1;
>         else f[i]=b==a?1:2;
>         res=max(res,f[i]);
>     }
>     return res;
> }
> ```

# 数组划分

> 分割数组以求最大和 https://leetcode.cn/problems/partition-array-for-maximum-sum/description/
>
> ```c++
> int maxSumAfterPartitioning(vector<int>& arr, int k) {
>     int n=arr.size();
>     vector<int> dp(n+1);
>     /*
>             dp[i]::=拆分数组前i项得到的最大和
>             dp[0]=0凑数(前0项)
>     */
> 
>     for(int i=1;i<=n;++i){
>         int m=arr[i-1];
>         for(int j=1;j<=k and i>=j;++j){
>             m=max(m,arr[i-j]);
>             dp[i]=max(dp[i-j]+m*j,dp[i]); //dp function
>         }
>         /*
>                 m::=arr[i-j,i-1]的最大值
>                 dp[i]=max{dp[i-j]+m*j , ... , dp[i-k]+m*k};
>         */
>     }
>     return dp[n];
> }
> ```

> 填充书架 https://leetcode.cn/problems/filling-bookcase-shelves/
>
> ```c++
> /* 局部最优不可导出全局最优 */
> int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
>     int n=books.size();
>     vector<int> dp(n+1,0x3f3f3f3f);
>     dp[0]=0;
>     /*
>             dp[i]::=前i本书的最小排布高度
>             dp[0]=0 凑数
>     */
> 
>     for(int i=1;i<=n;++i){ /* 等价于分割数组以求最小和 */
>         int h=books[i-1][1];
>         int w=0;
>         for(int j=1;j<=i and books[i-j][0]+w<=shelfWidth;++j){
>             h=max(h,books[i-j][1]);
>             dp[i]=min(dp[i-j]+h,dp[i]); /* 把后几本书放在一排 */
>             w+=books[i-j][0];
>         }
>     }
>     return dp[n];
> }
> ```

> 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/description/
>
> <img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/lQDPKdk1Rf3_lPHNAwzNBP-wY2CU7Wubpq0HebFJMjqqAA_1279_780.jpg" alt="lQDPKdk1Rf3_lPHNAwzNBP-wY2CU7Wubpq0HebFJMjqqAA_1279_780" style="zoom:50%;" />
>
> ```c++
> vector<vector<string>> partition(string s) {
>     int n=s.length();
>     vector<vector<bool>> check(n,vector<bool>(n));
>     for(int i=n-1;i>-1;--i){
>         for(int j=i;j<n;++j){
>             if(s[i]==s[j]){
>                 if(i==j or i+1==j) check[i][j]=true;
>                 else check[i][j]=check[i+1][j-1];
>             }
>         }
>     }
>     vector<vector<vector<string>>> res(n);
>     res[0].push_back({s.substr(0,1)});
>     /* res[i]::= s[0,i]所有分割方案 */
>     for (int i = 1; i < n; ++i) {
>         if(check[0][i]) res[i].push_back({s.substr(0,i+1)}); /* Note */
>         for (int j = 1; j <= i; ++j) {
>             if(check[j][i]){
>                 string sub=s.substr(j,i-j+1);
>                 for(auto item:res[j-1]){
>                     item.push_back(sub);
>                     res[i].push_back(item);
>                 }
>             }
>         }
>     }
>     return res[n - 1];
> }
> ```
>
> 分割回文串2 https://leetcode.cn/problems/palindrome-partitioning-ii/description/
>
> ```c++
> int minCut(string s) {
>  int n=s.length();
>  vector<vector<bool>> check(n,vector<bool>(n));
>  /* check[i][j]::= s[i,j]是否为回文串 */
>  for(int i=n-1;i>-1;--i){
>      for(int j=i;j<n;++j){
>          if(s[i]==s[j]){	/* 首尾相等 */
>              if(i==j or i+1==j) check[i][j]=true; 
>              else check[i][j]=check[i+1][j-1]; /* 检查[i+1,j-1]是否为回文 */
>          }
>      }
>  }
>  vector<int> dp(n,0x3f3f3f3f);
> 	//dp[i] ::= [0,i]子串分割成回文的最小次数
> 
>  for(int i=0;i<n;++i){
>      if(check[0][i]) dp[i]=0; //本身是回文则无需分割
>      else for(int j=0;j<i;++j)
>          if(check[j+1][i]) 	
>              dp[i]=min(dp[i],dp[j]+1);
>  }
>  return dp[n-1];
> }
> ```

> 最低票价 https://leetcode.cn/problems/minimum-cost-for-tickets/description/
>
> ```c++
> int mincostTickets(vector<int>& days, vector<int>& cost) {
>     int n=days.size();
>     vector<int> dp(n);
>     dp[0]=min(cost[0],min(cost[1],cost[2]));
>     for(int i=1;i<n;++i){
>         /* case 1: days[i]在一天票内 */
>         int cost1=dp[i-1]+cost[0];
>         /* case 2: days[i]在七天票内 */
>         int cost2;
>         if(days[i]-days[0]+1<=7) cost2=cost[1];
>         else{
>             for(int j=1;j<=i;++j)
>                 if(days[i]-days[i-j]+1>7){
>                     cost2=dp[i-j]+cost[1];
>                     break; //Note
>                 }
>         }
>         /* case 3: days[i]在30天票内 */
>         int cost3;
>         if(days[i]-days[0]+1<=30) cost3=cost[2];
>         else{
>             for(int j=1;j<=i;++j)
>                 if(days[i]-days[i-j]+1>30){
>                     cost3=dp[i-j]+cost[2];
>                     break;
>                 }
>         }
>         dp[i]=min(cost1,min(cost2,cost3));
>     }
>     return dp[n-1];
> }
> ```

> 单词拆分 https://leetcode.cn/problems/word-break/description/
>
> ```c++
> bool wordBreak(string s, vector<string>& wordDict) {
>     unordered_set<string> dic;
>     for(string& s:wordDict) dic.insert(s);
>     int n=s.length();
>     vector<bool> dp(n);
>     /* dp[i]::=0~i子串可否拼凑 */
>     for(int i=0;i<n;++i){
>         if(dic.count(s.substr(0,i+1))) dp[i]=true;
>         else{
>             for(int j=1;j<=i;++j){
>                 if(dic.count(s.substr(j,i-j+1))) dp[i]=dp[j-1];
>                 if(dp[i]) break; //Note: 第一次变为true后就结束
>             }
>         }
>     }
>     return dp[n-1];
> }
> ```
>
> 单词拆分II https://leetcode.cn/problems/word-break-ii/description/
>
> *同分割回文串*
>
> ```c++
> vector<string> wordBreak(string s, vector<string>& wordDict) {
>     unordered_set<string> dic;
>     for(string& s:wordDict) dic.insert(s);
>     int n=s.length();
>     vector<vector<string>> dp(n); //dp[i]::= 0~i子串可成的句子
>     if(dic.count(s.substr(0,1))) dp[0].push_back(s.substr(0,1));
>     for(int i=1;i<n;++i){
>         if(dic.count(s.substr(0,i+1))) dp[i].push_back(s.substr(0,i+1));
>         for(int j=1;j<=i;++j){
>             if(dic.count(s.substr(j,i-j+1)))
>                 for(string t:dp[j-1]){
>                     t+=' '+s.substr(j,i-j+1);
>                     dp[i].push_back(t);
>                 }
>         }
>     }
>     return dp[n-1];
> }
> ```

# 两个数组

> 最长重复子数组 https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/
>
> ```c++
> int findLength(vector<int>& nums1, vector<int>& nums2) {
>     int m=nums1.size(),n=nums2.size();
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     //dp[i][j]::= nums1[0,i-1]和nums[0,j-1]的最长公共子数组长度（子数组末尾是nums1[i-1]==nums2[j-1]) 
>     int res=0;
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
>             res=max(res,dp[i][j]);
>         }
>     }
>     return res;
> }
> ```

> 最长公共子序列 https://leetcode.cn/problems/longest-common-subsequence/description/
>
> ```c++
> int longestCommonSubsequence(string s1, string s2) {
>     int m=s1.length(),n=s2.length(),res=0;
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     //dp[i][j]::= s1[0,i-1]和s2[0,j-1]的最长公共子序列长度
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
>             else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
>             res=max(res,dp[i][j]);
>         }
>     }
>     return res;
> }
> ```

> 不相交的线 https://leetcode.cn/problems/uncrossed-lines/description/
>
> ```c++
> int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
>     int m=nums1.size(),n=nums2.size(),res=0;
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     //dp[i][j]::= nums1[0,i-1]和nums[0,j-1]的最长公共子序列长度
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
>             else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
>             res=max(res,dp[i][j]);
>         }
>     }
>     return res;
> }
> ```

> 两个字符串删除操作 https://leetcode.cn/problems/delete-operation-for-two-strings/description/
>
> ```c++
> /*最长公共子序列问题*/
> int minDistance(string word1, string word2) {
>     int m=word1.length(),n=word2.length(),res=0;
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
>             else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
>             res=max(res,dp[i][j]);
>         }
>     }
>     return m+n-2*res;
> }
> ```

> 两个字符串最小ASCII删除和 https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/
>
> ```c++
> int minimumDeleteSum(string s1, string s2) {
>  int sum=0;
>  for(char ch:s1) sum+=ch;
>  for(char ch:s2) sum+=ch;
>  int m=s1.length(),n=s2.length(),res=0;
>  vector<vector<int>> dp(m+1,vector<int>(n+1));
>  //dp[i][j]::= s1[0,i-1]和s2[0,j-1]中ASCII和最大的公共子序列
>  for(int i=1;i<=m;++i){
>      for(int j=1;j<=n;++j){
>          if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+s1[i-1];
>          else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
>          res=max(res,dp[i][j]);
>      }
>  }
>  return sum-2*res;
> }
> ```
>
> 最短公共超序列 https://leetcode.cn/problems/shortest-common-supersequence/description/
>
> ```c++
> string shortestCommonSupersequence(string s1, string s2) {
>     int m=s1.length(),n=s2.length();
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     //dp[i][j]::= s1[0,i-1]和s2[0,j-1]中的最长公共子序列长度
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
>             else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
>         }
>     }
>     
>     string res;
>     int i=m-1,j=n-1;
>     while(i>-1 and j>-1){
>         if(s1[i]==s2[j]){
>             res=s1[i]+res;
>             --i,--j;
>         }else{
>             if(dp[i+1][j+1]==dp[i][j+1]){
>                 res=s1[i]+res;
>                 --i;
>             }else{
>                 res=s2[j]+res;
>                 --j;
>             }
>         }
>     }
>     if(i>-1) res=s1.substr(0,i+1)+res;
>     if(j>-1) res=s2.substr(0,j+1)+res;
>     return res;
> }
> ```

> 交错字符串 https://leetcode.cn/problems/interleaving-string/description/
>
> ![lQDPJxFQubJClnXNAZrNBP6wiY3Iqu6sIO4HfJoUnWZKAA_1278_410](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/lQDPJxFQubJClnXNAZrNBP6wiY3Iqu6sIO4HfJoUnWZKAA_1278_410.jpg)
>
> ```c++
> bool isInterleave(string s1, string s2, string s3) {
>     int m=s1.length(),n=s2.length(),l=s3.length();
>     if(m+n!=l) return false;
>     s1=' '+s1,s2=' '+s2,s3=' '+s3;
>     vector<vector<bool>> dp(m+1,vector<bool>(n+1));
>     dp[0][0]=true;
>     for(int i=0;i<=m;++i){
>         for(int j=0;j<=n;++j){
>             if(i==0 and j==0) continue;
>             dp[i][j]=(s1[i]==s3[i+j] and dp[i-1][j]) or (s2[j]==s3[i+j] and dp[i][j-1]);
>         }
>     }
>     return dp[m][n];
> }
> ```

> 不同子序列 https://leetcode.cn/problems/distinct-subsequences/description/
>
> ```c++
> int numDistinct(string s, string t) {
>     int lens=s.length(),lent=t.length();
>     vector<vector<double>> dp(lens+1,vector<double>(lent+1));
>     for(int i=0;i<=lens;++i) dp[i][0]=1;
>     for(int i=1;i<=lens;++i){
>         for(int j=1;j<=lent;++j){
>             dp[i][j]+=dp[i-1][j];
>             if(s[i-1]==t[j-1]) dp[i][j]+=dp[i-1][j-1];
>         }
>     }
>     return dp[lens][lent];
> }
> ```

> 通配符匹配 https://leetcode.cn/problems/wildcard-matching/description/
>
> ![lQDPKeUAy9Wlg6XNAwXNBP-w8f1cNEv9EpIHfIOdi9EqAA_1279_773](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/lQDPKeUAy9Wlg6XNAwXNBP-w8f1cNEv9EpIHfIOdi9EqAA_1279_773.jpg)
>
> ```c++
> bool isMatch(string s, string p) {
>  int m=s.length(),n=p.length();
>  vector<vector<bool>> dp(m+1,vector<bool>(n+1));
>  dp[0][0]=true;
>  for(int i=0;i<n;++i) {
>      if(p[i]=='*') dp[0][i+1]=true;
>      else break;
>  }
>  for(int i=1;i<=m;++i){
>      for(int j=1;j<=n;++j){
>          if(p[j-1]<='z' and p[j-1]>='a') dp[i][j]=dp[i-1][j-1] and s[i-1]==p[j-1];
>          else if(p[j-1]=='?') dp[i][j]=dp[i-1][j-1];
>          else dp[i][j]=dp[i][j-1] or dp[i-1][j];
>      }
>  }
>  return dp[m][n];
> }
> ```
>
> 正则表达式匹配 https://leetcode.cn/problems/regular-expression-matching/description/
>
> ![lQDPJyGfTmj2zp3NAcbNBP6w2teb4MsGIsQHfZ7TnbDbAA_1278_454](https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/lQDPJyGfTmj2zp3NAcbNBP6w2teb4MsGIsQHfZ7TnbDbAA_1278_454.jpg)
>
> ```c++
> bool isMatch(string s, string p) {
>     int m=s.length();
>     int n=p.length();
>     vector<vector<bool>> dp(m+1,vector<bool>(n+1));  /*s1[0,i]可否匹配于s2[0,j]*/
>     dp[0][0]=true;
>     s=' '+s;p=' '+p;
>     for(int i=2;i<=n;i+=2){	//初始化_*_*_*__遇到2个非连续的*号停止
>         if(p[i]!='*') break;
>         dp[0][i]=true;
>     }
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(p[j]=='*') dp[i][j]=dp[i][j-2] or dp[i-1][j] and (p[j-1]=='.' or s[i]==p[j-1]);
>             else dp[i][j]=dp[i-1][j-1] and (s[i]==p[j] or p[j]=='.');
>         }
>     }
>     return dp[m][n];
> }
> ```

> 编辑距离 https://leetcode.cn/problems/edit-distance/description/
>
> ```c++
> int minDistance(string word1, string word2) {
>     int m=word1.length(),n=word2.length();
>     vector<vector<int>> dp(m+1,vector<int>(n+1));
>     for(int j=1;j<=n;++j) dp[0][j]=j;  //引入空串
>     for(int i=1;i<=m;++i) dp[i][0]=i;
>     for(int i=1;i<=m;++i){
>         for(int j=1;j<=n;++j){
>             if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
>             else dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1; /*增删替*/
>         }
>     }
>     return dp[m][n];
> }
> ```

# K个数组

动规数组的i=0行和j=0行的作用是方便下标运算，其值是没有意义的，当j=1即表示拆分成1个数组时应该单独考虑，因为把前x个元素拆成j-1(0)个数组是没有意义的，无法判断dp[x]\[0]应该赋值为多少

> 最大平均值和的分组 https://leetcode.cn/problems/largest-sum-of-averages/description/
>
> ```c++
> double largestSumOfAverages(vector<int>& nums, int k) {
>     int n = nums.size();
>     vector<double> preSum(n + 1);
>     for (int i = 1; i <= n; ++i) {
>         preSum[i] = preSum[i - 1] + nums[i - 1];
>     }
>     vector<vector<double>> dp(n + 1, vector<double>(k + 1));
>     for (int i = 1; i <= n; ++i) {
>         dp[i][1] = preSum[i] / i;
>         for (int j = 2; j <= i and j <= k; ++j) {
>             for (int x = j - 1; x < i; ++x) {
>                 double v = dp[x][j - 1] + (preSum[i] - preSum[x]) / (i - x);
>                 dp[i][j] = max(dp[i][j], v);
>             }
>         }
>     }
>     return dp[n][k];
> }
> ```

> 分割回文串 III https://leetcode.cn/problems/palindrome-partitioning-iii/
>
> ```c++
> int palindromePartition(string s, int k) {
>     int n=s.length();
>     vector<vector<int>> g(n+1,vector<int>(n+1)); //g(i,j)::= i~j变成回文串的修改次数
>     for(int i=n;i>=1;--i){
>         for(int j=i;j<=n;++j){
>             if(i==j) continue;
>             else if(i+1==j and s[i-1]!=s[j-1])  g[i][j]=1;
>             else{
>                 g[i][j]=g[i+1][j-1];
>                 if(s[i-1]!=s[j-1]) g[i][j]++;
>             }
>         }
>     }
>     vector<vector<int>> f(n+1,vector<int>(k+1,0x3f3f3f3f)); 
>     //f(i,j)::= 前i个字符拆为j个回文串最少修改次数
>     for(int i=1;i<=n;++i){
>         f[i][1]=g[1][i];
>         for(int j=2;j<=i and j<=k;++j){
>             for(int x=j;x<=i;++x){
>                 f[i][j]=min(f[i][j],f[x-1][j-1]+g[x][i]);
>             }
>         }
>     }
>     return f[n][k];
> }
> ```

> 分割数组的最大值 https://leetcode.cn/problems/split-array-largest-sum/
>
> ```c++
> int splitArray(vector<int>& nums, int k) {
>     int n=nums.size();
>     vector<int> preSum(n+1);
>     for(int i=1;i<=n;++i) preSum[i]=preSum[i-1]+nums[i-1];
>     vector<vector<int>> dp(n+1,vector<int>(k+1,0x3f3f3f3f));
>     //dp[i][j]::=前i项拆为j个数组的最大和中的最小值
>     /*	k=2 nums=[7,2,5,10,8]
>     	[7][2,5,10,8]->25
>     	[7,2][5,10,8]->23
>     	[7,2,5][10,8]->18
>     	[7,2,5,10][8]->24
>     	min{25,23,18,24}=18
>     */
>     for(int i=1;i<=n;++i){
>         dp[i][1]=preSum[i];
>         for(int j=2;j<=i and j<=k;++j){
>             for(int x=j-1;x<i;++x){
>                 int v=max(dp[x][j-1],preSum[i]-preSum[x]);
>                 dp[i][j]=min(dp[i][j],v);
>             }
>         }
>     }
>     return dp[n][k];
> }
> ```

