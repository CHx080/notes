# 主存结构

![img](https://i-blog.csdnimg.cn/direct/b264e170c99643929da7af33ed0e6c63.png)

内存条由多个Chip组成(*对应实物图中的黑色芯片*)，每个Chip负责保存数据的部分比特位，多个Chip联合构成一个Rank。一个Rank可以提供一个完整的数据。

> *32GB 2R×4表示该内存条的容量为32GB，2个Rank，每个Chip保存数据的4bit。64位机下一个Rank由16个Chip组成*

Chip内部是一个三维结构，表现为多个Bank，每个Bank以矩阵形式保存数据。**Bank中有一个Row buffer充当行缓冲**。

![img](https://i-blog.csdnimg.cn/direct/6344f83add1647aa97931b825401c9f4.png)

**Bank中每一个单元至少需要保存内存颗粒宽位数据** *(假设一块内存条规格为2Rx4,则每一个Bank的矩形单元至少保存4bit)*

# 访存延迟

***主存延迟参数***

| **CL（Column Address Latency）**                | **发送一个列地址到内存与数据开始响应之间的时钟周期数** |
| ----------------------------------------------- | ------------------------------------------------------ |
| **tRCD（Row Address to Column Address Delay）** | **打开一行内存并访问其中的列所需的最小时钟周期数**     |
| **tRP（Row Pre charge Time)**                   | **发出预充电命令与打开下一行之间所需的最小时钟周期数** |
| **tRAS（Row Active Time)**                      | **两次预充电命令之间所需的最小时钟周期数**             |

# 访存流程

**1、激活Chip芯片，发出预充电信号——消耗tRP时间**

![img](https://i-blog.csdnimg.cn/direct/07b53fab563e4746ac8dc649a3724598.png)

**2、激活指定Bank行——消耗tRCD时间**

![img](https://i-blog.csdnimg.cn/direct/bdbadc4716f54b0b93ad3cb4031fc1f6.png)

> *注意到这一步把同一行的数据都拷贝到了row buffer*

**3、激活指定Bank列——消耗CL时间**

![img](https://i-blog.csdnimg.cn/direct/c9eee383ece2473ab0b4c1dd8036df12.png)

## **数据对齐**

**在访存的第二步主存把同一行的数据都已经拷贝到了rowbuffer中，这表明如果接下来要访问紧邻的数据只需要消耗一个CL时间即可，不需要Chip预充电和行激活的操作。这也是为什么随机访存的速读要比顺序访存速度慢的原因。**

我们希望一个字段可以访问一次主存就可以被完整的读取，这就需要尽量使得数据在每一个Chip中的部分在同一行。这个操作成为数据对齐。

![img](https://i-blog.csdnimg.cn/direct/3da41646e7704663b5cdf973e9cf96f6.png)

如果没有经过数据对齐，读取long类型的数据就需要进行2次行激活，多了一次tRCD时间

**数据对齐直接体现在C语言的结构体中**

```c
struct A{
    int field1;
    char field2;
    long field3;
}; //sizeof(A)不为13,而是16
struct B{
    char field0;
    struct A field1;
};//sizeof(B)为24 [等价于把A展开]
struct C{};
	//sizeof(C)空结构体大小为1字节
```

> ### C结构体对齐规则
>
> 类型大小与编译器对齐大小取小(*记位x*)   `①`
>
> 数据的地址起始位置必须是x的整数倍数
>
> 结构体的大小需要为最大数据类型的整数倍(*如有内嵌结构体则展开计算*)

​	↓

> ①中的编译器对齐大小由预编译指令**#pragma pack(n)**指定，默认为8
>
> *#pragma pack(1) 表示不进行数据对齐*

## **端序**

**对于多字节的数据存储分为大端序和小端序。**

**大端序：数据低位保存在高地址**

**小端序：数据低位保存在低地址**

> ***检验平台端序***

```c
int x=0xaabbccdd;
int main(){
    char *p=(char*)&x;
    printf("%s\n",*p==0xaa ? "小段" : "大端");
    return 0;
}
```

# 虚拟存储

> 为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。 虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力 ： 1)**将主存看成是磁盘的高速缓存** ，在主存中只保存活动区域 ，并根据需要在磁盘和主存之间来回传送数据。 2)为每个进程提供了一致的地址空间， 简化内存管理。 3)它保护了每个进程的地址空间不被其他进程破坏。  

**主存和磁盘使用的是全相联映射**。

虚拟存储引入地址空间的概念，地址空间是一组连续的无符号整数集合。可视为一个存放在磁盘上大小为N字节数组。每字节都有一个唯一的**虚拟地址**，作为数组索引。

将地址空间等分为数个单元成为**页**，部分页有对应的物理页(**页帧**)。没有物理页对应的页表示无效页或页数据位于磁盘。

> 虚拟页面的集合分为三个不相交子集
>
> ***未分配： 未分配(或者创建)的页。 未分配的块没有任何数据和它们相关联 ，不占用任何空间***
>
> ***已缓存 ：已缓存在物理内存中的已分配页***
>
> ***未缓存： 未缓存在物理内存中的已分配页，数据在磁盘上***

虚拟地址到物理地址的转换由硬件和软件联合完成。硬件上CPU中的**内存管理单元MMU**计算地址，软件上操作系统需要在主存中维护一张**页表**用于记录虚拟页和物理页的映射关系。*(MMU在计算地址时需要访问驻留在主存中的页表,每个**进程私有页表**)*

页表的数据项称为**页表项(Page Table Entry —— PTE)**，页表项一定存在一个有效标记位以指示页是否有对应页帧和地址字段。

对于已分配的页,**有效标记位为1则地址字段是主存地址，否则地址字段是磁盘地址**。

如果MMU发现对应的页表项是未缓存的，则引发一个**缺页中断**，确保进程正常合法访存的前提下将磁盘中的数据调入主存。

![img](https://i-blog.csdnimg.cn/direct/ef706edfa64a46618c857abda3b69922.png)

## 虚拟地址划分

虚拟地址由**页号和页偏移**2部分组成，页号即页表索引，页偏移用于定位一页中的具体位置*(按字节编址如果页偏移字段有n位，则一页大小为2^n^Bytes)*

MMU可以通过页基址寄存器访问页表，通过传入的虚拟地址获得页号和页偏移。

![img](https://i-blog.csdnimg.cn/direct/a48c0947166e4a63980b9d6804f0a98e.png)

## 多级页表

64位环境页表太太主存无法容纳，因此对页表再进行粗粒度划分，产生页表项是页表的页表——**多级页表**

**Linux采用了4级页表，逻辑地址仅使用了低48位**

低12用作页内偏移(*故Linux页大小为4096Bytes*)

每一级页表的页表项都指向了下一级页表所在的物理地址

**一级页表的物理地址由寄存器指向，作为进程上下文的一部分**

![img](https://i-blog.csdnimg.cn/direct/4a42a13f6de14361b46585bc79d84357.png)

## 简化内存管理

虚拟内存简化了内存管理，为进程提供了一个大于实际值的地址空间，并提供了一种自然的保护内存的方法 

> ### 简化链接

> *独立的地址空间允许每个进程的内存映像使用相同的基本格式， 而不管代码和数据实际存放在物理内存的何处。这样的一致性简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，可执行文件是独立于物理内存中代码和数据的最终位置的。*

> ### 简化加载

> *向内存中加载可执行文件和共享对象文件变得简单。加载器从不从磁盘到内存实际复制任何数据。在每个页*
>
> *初次被引用时引发缺页让系统**按需调页**。一定程度上加快了程序启动。*

> ### 简化共享

> *只需要把不同的进程页表页面项指向一个相同的物理页，即可实现进程间共享数据。*

> ### 简化内存分配

> *由于页表工作的方式，操作系统没有必要分配是个连续的物理内存页面。页面可以随机地分散在物理内存中。即虚拟地址连续不代表物理地址连续。*

> ### 提供内存保护

> 页表项中可以设置相应的权限位阻止受保护的内存单元被进程非法访问。