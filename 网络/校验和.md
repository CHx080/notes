数据链路层负责实现**<u>相邻节点</u>**之间的数据传输。链路层并不要求实现数据的可靠传输，部分链路层协议是不可靠的，可靠性有传输层完成。但是它们通常都具有校验机制。

数据链路层的协议数据单元PDU称为**<u>帧</u>**。

物理层在传输比特流时会收到干扰导致比特位反转导致信息出现差错，数据链路层对此进行差错处理，首先需要将比特流划分为一个个**帧**方便处理。

## 组帧

### 字节填充字节标记法

字节填充字节标记法引入了一个**<u>转义字符</u>**作为数据帧的定界符并要求帧长度8字节对齐，只需要获取到2个转义字符，那么就可判定它们之间即为一个数据帧。

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250309135359942.png" alt="image-20250309135359942" style="zoom:50%;" />

设定的转义字符应该很少出现在数据帧中，但是如果数据帧中的确需要传输转义字符，那么就必须引入一个**<u>反转义字符</u>**来避免错误地帧划分。

### 位填充字节标记法

位填充字节标记法通过引入**<u>位串</u>**作为数据帧定界符，其不要求帧长度8字节对齐，并且位串只会出现在数据帧2侧，因此相比于字节填充标记法其信道利用率更高。

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250309135651012.png" alt="image-20250309135651012" style="zoom:50%;" />

位串的选取是多样的，假设以位串*0111 1110*作为帧定界符，为了避免与数据帧的内容混淆，发送端在发送数据帧时连续发送5个比特1时强制补充1位0，以此避免形成连续6个1引起混淆\~~~变相导致*0111 1110*只会出现在数据帧2侧。接收端解析连续的5个比特1时根据后一位就可轻松判断是否为定界符。

------

------

------

完成了组帧，下一步是差错处理。差错处理分为**<u>检错</u>**和**<u>纠错</u>**

检错由发送端处理，接收端在收到错误数据帧时丢弃，等待发送端重传。

纠错由接收端处理，接收端根据冗余信息定位错误位并修正。

## 检错

### 奇偶校验

奇偶校验是检错方式里最简单的一种，只有在奇数位出错时才能捕获错误*(1位出错的概率较大)*

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250309141042915.png" alt="image-20250309141042915" style="zoom:50%;" />

奇偶校验分为奇校验和偶校验，二者都引入了1位校验位

*对于奇校验*	统计数据位中1的个数，如果为奇数个，**则校验位补0，反之补1**——即使1的位数为奇数个

*对于偶校验*	统计数据位中1的个数，如果为奇数个，**则校验位补1，反之补0**——即使1的位数为偶数个

**<u>一旦发生了奇数位比特反转，就必然导致收发两端的校验和不一致，从而捕获错误。</u>**

### 循环冗余校验(CRC)

循环冗余校验是比奇偶校验检错能力更强的检错算法，其引入了一个**<u>生成多项式G(x)</u>** *(G(x)的本质是一个位串)*，并将数据位记作**M(x)**，

将M(x)的低位补上r个0 *(r为G(x)的次数)*记作**x^r^ M(x)**。将x^r^ M(x)模2除以G(x)得到余数**c**，**即校验和**。

发送端将x^r^ M(x)的补0段替换为c后交付给物理层传输。

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/image-20250309141934053.png" alt="image-20250309141934053" style="zoom:50%;" />

接收端在收到数据后将帧数据模2除以G(x)，如果可以整除就判定为数据无误，反之则捕获错误。*(生成函数G(x)在收发双方正式通信前协定)*

### 互联网校验

互联网校验基于**<u>反码加法</u>**运算

> ​	1	0	1	0
>
> \+      1	0	0	0
>
> -------------------------------------------
>
> ​	0	0	1	1		---最高位进位则末位+1
>
> -----
>
> ​	1	1	0	0		---取反

将1100作为校验和与数据一起发送，接收方在收到数据后以4位一组进行反码求和，若结果为非0则捕获错误

> ​	1	0	1	0
>
> ​        1	0	0	0
>
> \+      1	1	0	0
>
> -----
>
> ​	1	1	1	1		
>
> ----
>
> ​	0	0	0	0		---取反		---结果为0->无误

## 纠错

### 海明距离

2个二进制表示的码值，其比特位不同的位数称为**<u>海明距离</u>**(简称码距)

> *例如：0111 和 1100的码距为3	1110 和 1111的码距为1*

<u>**对于一组编码集合，其海明距离为集合中码距最小的2个码值的码距**</u>

==**<u>一组海明距离为2d+1的编码集合，可以实现d位纠错</u>**==

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/83c13698e2a17c5a11c2dca88c642be.jpg" alt="83c13698e2a17c5a11c2dca88c642be" style="zoom:50%;" />

### 纠1位错-海明码

设数据位m位，校验位r位，码长n位
$$
n=m+r  \\
2^m+n*2^m\leq 2^n  \\		
得m+r+1 \leq 2^r
$$
*(2^m^表示正确值的个数,n\*2^m^表示每一个正确值所对应的1位出错方案)*

根据公式可知假设数据位有8位，那么校验位至少需要4位才能实现1位纠错



海明编码结合了奇偶校验，以偶校验为例

*纠1位错海明编码过程:*

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/29178c19ac232a3e308ca7b9cf5626b.jpg" alt="29178c19ac232a3e308ca7b9cf5626b" style="zoom:50%;" />

**接收方收到数据帧后重新计算各个校验位，将出现错误的校验位对应的编号求和即可定位到出错位**

*数据位本身的码距为1，任意1位数据位的变动都讲导致至少2个校验位反转 (数据位最小编号-3)，因此保证了有效编码方案的海明距离至少为3，从而支持实现1位纠错*