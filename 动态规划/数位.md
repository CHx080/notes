> 先不考虑上限,再考虑上限,从高位向低位枚举

# 最大为N的数字组合

https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/

```c++
int atMostNGivenDigitSet(vector<string>& digits, int n) {
    string num=to_string(n);
    int cnt=num.size(),m=digits.size();
    auto dp=vector(cnt+1,(long)1);
    /*dp(i)表示i位数的组合数*/
    int res=0;
    for(int i=1;i<=cnt;++i) {dp[i]=dp[i-1]*m;if(i<cnt) res+=dp[i];}
    /*位数小于 n的位数的数一定满足的*/
    // 处理位数等于 n 的位数的数
    for (int i = 0; i < cnt; ++i) {
        bool hasSame = false;
        int temp = 0; // temp 为 digits 中比 num[i] 小的数的个数
        for (int j = 0; j < m; ++j) {
            if (digits[j][0] < num[i]) ++temp;
            else if (digits[j][0] == num[i]) hasSame = true;
        }
        res += temp * dp[cnt - i - 1];
        // 如果没有找到与当前位相等的数字，直接返回结果
        if (!hasSame) return res;
    }
    // 如果能组成 n，结果加 1
    return res + 1;
}

```

# 旋转数字

https://leetcode.cn/problems/rotated-digits/description/

```c++

```

# 至少1位重复数字

https://leetcode.cn/problems/numbers-with-repeated-digits/description/

```c++

```

# 1的个数

https://leetcode.cn/problems/number-of-digit-one/description/

```c++

```

# 不含连续1非负整数

https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/description/

```c++

```

