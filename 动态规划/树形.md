---

# 二叉树深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/

```c++
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    int leftDepth=maxDepth(root->left);
    int rightDepth=maxDepth(root->right);
    return max(leftDepth,rightDepth)+1;
}
```

# 二叉树最小深度

https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/

```c++
int minDepth(TreeNode* root) {
    if(!root) return 0;
    if(!root->left) return minDepth(root->right)+1;
    else if(!root->right) return minDepth(root->left)+1;
    else return min(minDepth(root->left),minDepth(root->right))+1;
}
```

# 平衡树判断

https://leetcode.cn/problems/balanced-binary-tree/description/

```c++
bool isBalanced(TreeNode* root) {
    if(!root) return true;
    int leftTreeDepth=maxDepth(root->left);
    int rightTreeDepth=maxDepth(root->right);
    if(abs(leftTreeDepth-rightTreeDepth)>1) return false;
    return isBalanced(root->left)&&isBalanced(root->right);
}
```

# 二叉树直径

https://leetcode.cn/problems/diameter-of-binary-tree/

```c++
unordered_map<TreeNode*,int> depth; /*记忆化搜索——剪枝,避免重复地高度计算*/
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    if(depth.count(root)) return depth[root];
    int leftDepth=maxDepth(root->left);
    int rightDepth=maxDepth(root->right);
    int temp=max(leftDepth,rightDepth)+1;
    depth[root]=temp;
    return temp;
}
/* 左子树最长路径+右子树最长路径=经过某节点的直径 */
int res=0;
void _diameterOfBinaryTree(TreeNode* root) {
    if(!root->left and !root->right) return;
    int leftDia=maxDepth(root->left);
    int rightDia=maxDepth(root->right);
    res=max(res,leftDia+rightDia);
    if(root->left) _diameterOfBinaryTree(root->left);
    if(root->right) _diameterOfBinaryTree(root->right);
}
int diameterOfBinaryTree(TreeNode* root) {
    _diameterOfBinaryTree(root);
    return res;
}
```

# 最长同值路径

https://leetcode.cn/problems/longest-univalue-path/

```c++
int res=0;
int _longestUnivaluePath(TreeNode* root){
    if(!root->left and !root->right) return 0;
    int leftPath=0,rightPath=0;//左右子树的同值路径
    int len=0;//当前节点的同值路径
    int ret=0;//左右较长的同值路径
    if(root->left) {
        leftPath=_longestUnivaluePath(root->left);
        if(root->left->val==root->val) {len+=leftPath+1;ret=len;}
    }
    if(root->right) {
        rightPath=_longestUnivaluePath(root->right);
        if(root->right->val==root->val) {len+=rightPath+1;ret=max(ret,rightPath+1);}
    }
    res=max(res,len);
    return ret;
}
int longestUnivaluePath(TreeNode* root) {
    if(!root) return 0;
    _longestUnivaluePath(root);
    return res;
}
```

# 最大路径和

https://leetcode.cn/problems/binary-tree-maximum-path-sum/

```c++
/*
    关联当前节点的最大路径和,若已知左侧最大路径和为L,右侧最大路径和为R
    左右侧均为正数则都取,仅一个为正数则取正的,都为非正数则不取,取值记为X
    记V为当前节点值,使用X+V更新全局结果
*/
int res=INT_MIN;
int _maxPathSum(TreeNode* root){
    if(!root) return 0;
    int L=_maxPathSum(root->left);
    int R=_maxPathSum(root->right);
    int X=max({L+R,L,R,0}),V=root->val;
    res=max(res,X+V);
    return V+max({L,R,0});
}
int maxPathSum(TreeNode* root) {
    _maxPathSum(root);
    return res;
}
```

----

----

----

# 分配硬币

https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/

```c++

```

# 频次最高的子树元素和

https://leetcode.cn/problems/most-frequent-subtree-sum/description/

```c++

```

# 打家劫舍III

https://leetcode.cn/problems/house-robber-iii/description/

```c++
/* 
    _rob返回当前节点偷与不偷的最大金额 
    如果选择偷,那么左右节点必须都不偷
    如果选择不偷,那么左右节点随意
*/
pair<int,int> _rob(TreeNode* cur){  
    if(!cur->left && !cur->right) return {cur->val,0};//处理叶子节点
    pair<int,int> left={0,0},right={0,0};
    if(cur->left) left=_rob(cur->left);
    if(cur->right) right=_rob(cur->right);
    int steal=cur->val+left.second+right.second;
    int unsteal=max({left.first+right.first,
                     left.first+right.second,
                     left.second+right.first,
                     left.second+right.second});
    return {steal,unsteal};
}
int rob(TreeNode* root) {
    pair<int,int> res=_rob(root);
    return max(res.first,res.second);
}
```

# 监控二叉树

https://leetcode.cn/problems/binary-tree-cameras/description/

```c++
/*
    当前节点装摄像头标记为蓝色
    当前节点不装摄像头且父节点装摄像头标记为黄色
    当前节点不装摄像头且把摄像头装载左/右节点标记为红色
    记录cur为根的子数最少摄像头为N个
    根据当前节点cur进行分类讨论
    if cur为蓝色,那么N=min{左蓝,左黄,左红}+min{右蓝,右黄,右红}+1
    if cur为黄色,那么N=min{左蓝,左红}+min{右蓝,右红}
    if cur为红色,那么N=min{左蓝+右蓝,左蓝+右红,左红+右蓝}
*/
//_minCameraCover返回子树根节点三种颜色(蓝黄红)所需的最小摄像头数量
array<int,3> _minCameraCover(TreeNode* cur){
    if(!cur) return {0x3f3f3f3f,0,0};
    array<int,3> left=_minCameraCover(cur->left);
    array<int,3> right=_minCameraCover(cur->right);
    int bule=min({left[0],left[1],left[2]})+min({right[0],right[1],right[2]})+1;
    int yellow=min(left[0],left[2])+min(right[0],right[2]);
    int red=min({left[0]+right[0],left[0]+right[2],left[2]+right[0]});
    return {bule,yellow,red};
}
int minCameraCover(TreeNode* root) {
    auto res=_minCameraCover(root);
    return min(res[0],res[2]);
}
```

----

---

---

# 建立四叉树

https://leetcode.cn/problems/construct-quad-tree/description/

<img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/bd393a6d0941b53845093e59cef2dc5.jpg" alt="bd393a6d0941b53845093e59cef2dc5" style="zoom: 33%;" />

```c++
vector<vector<int>> grid;
bool isSame(int x,int y,int i,int j){
    int base=grid[x][y];
    for(int k=x;k<=i;++k) for(int t=y;t<=j;++t) if(grid[k][t]!=base) return false;
    return true;
}
Node* _construct(int x,int y,int i,int j){
    if(isSame(x,y,i,j) || x==i) return new Node(grid[x][y],true); /*无需分块和无法分块*/
    Node *topLeft=_construct(x,y,(x+i)/2,(y+j)/2),
    *topRight=_construct(x,(y+j)/2+1,(x+i)/2,j),
    *bottomLeft=_construct((x+i)/2+1,y,i,(y+j)/2),
    *bottomRight=_construct((x+i)/2+1,(y+j)/2+1,i,j);
    return new Node(1,false,topLeft,topRight,bottomLeft,bottomRight);
}
Node* construct(vector<vector<int>>& matrix) {
    grid=matrix;int n=matrix.size()-1;
    return _construct(0,0,n,n);
}
```

# 四叉树交集

https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/description/

```c++

```

# 树中距离之和

https://leetcode.cn/problems/sum-of-distances-in-tree/description/

```c++

```

# 多叉树深度

https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/

```c++
int maxDepth(Node* root) {
    if(!root) return 0;
    int temp=0;
    for(Node* child:root->children) temp=max(temp,maxDepth(child));
    return 1+temp;
}
```

