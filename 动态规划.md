# 左右数组

> 接雨水 https://leetcode.cn/problems/trapping-rain-water/description/
>
> ```cpp
> int trap(vector<int>& height) {
>     int n=height.size();
>     vector<int> dp_left_max(n+1);
>     auto dp_right_max=dp_left_max;
>     /*
>     	dp_left_max[i]::=[0,i-1] 最大值
>     	dp_right_max[i]::=[i,n) 最大值
>     */
>     
>     /* dp function */
>     for(int i=1;i<=n;++i) dp_left_max[i]=max(height[i-1],dp_left_max[i-1]);
>     for(int i=n-1;i>=0;--i) dp_right_max[i]=max(height[i],dp_right_max[i+1]);
> 
>     int ret=0;
>     for(int i=0;i<n;++i) ret+=max(min(dp_left_max[i],dp_right_max[i+1])-height[i],0);
>     /* 如果本格最高则设置为0,否则会ret会加上一个负数导致结果错误 */
>     return ret;
> }
> ```
>

> 股票 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
>
> ```c++
> int maxProfit(vector<int>& prices) {
>     int n=prices.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]天最便宜的 , g[i]::=[i+1,n)天最贵的 */
>     
>     f[0]=prices[0],g[n-1]=0;
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],prices[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],prices[i+1]);
>     
>     int ret=0;
>     for(int i=0;i<n;++i) ret=max(ret,g[i]-f[i]);
>     return ret;
> }
> ```

> 递增三元子序列 https://leetcode.cn/problems/increasing-triplet-subsequence/description/
>
> ```c++
> bool increasingTriplet(vector<int>& nums) {
>     int n=nums.size();
>     if(n<3) return false;
>     vector<int> f(n),g(n);f[0]=nums[0],g[n-1]=nums[n-1];
>     /* f[i]::=[0,i]最小值,g[i]::=[i,n-1]最大值 */
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=min(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=max(g[i+1],nums[i]);
> 
>     for(int i=1;i<n-1;++i) if(f[i-1]<nums[i] and nums[i]<g[i+1]) return true;
>     /* i左侧最小<[i]<i右侧最大 */
>     return false;
> }
> ```

> 分割数组 https://leetcode.cn/problems/partition-array-into-disjoint-intervals/description/
>
> ```c++
> int partitionDisjoint(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>=0;--i) g[i]=min(g[i+1],nums[i]);
>     
>     for(int i=0;i<n-1;++i) if(f[i]<=g[i+1]) return i+1;
>     /* 左最大<=右最小即可分割为2个数组 */
>     return -1;
> }
> ```

> 最短无序子数组 https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/
>
> ```c++
> int findUnsortedSubarray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
>     
>     f[0]=nums[0],g[n-1]=nums[n-1];
>     /* dp function */
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],nums[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],nums[i]);
> 
>     int left=0,right=n-1;
>     while(left<n){
>         if(f[left]>g[left]) break;
>         ++left;
>     }
>     while(right>-1){
>         if(f[right]>g[right]) break;
>         --right;
>     }
>     if(left<right) return right-left+1; /* 最右失序点-最左失序点+1 */
>     return 0; /* Note:left>=right表示数组是有序的,返回0 */
> }
> ```

> **排序分块** https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/description/
>
> <img src="https://chx-typora.oss-cn-hangzhou.aliyuncs.com/typora/34fa59deea83729fe1bf868680230c21.jpg" alt="34fa59deea83729fe1bf868680230c21" style="zoom:50%;" />
>
> ```c++
> vector<int> f,g;
> /* f[i]::=[0,i]最大值,g[i]::=[i,n-1]最小值 */
> int ret = 0;
> void dfs(vector<int>& arr, int left, int right) {
>     if (left >= right) { ++ret; return; } /* 长度为1的数组 */
>     
>     for (int i=left; i < right; ++i) {
>         if (f[i] <= g[i + 1]) { 
>             dfs(arr, left, i), dfs(arr, i + 1, right); 
>             return;  /* 对于任意长度大于1的数组,只要存在i下标使得max{[left:i]}<=min{[i+1,right]}即可分块*/
>         }
>     }
>     ++ret; /* 不可分块的数组 */
> }
> int maxChunksToSorted(vector<int>& arr) {
>     int n=arr.size();
>     f.resize(n),g.resize(n);
>     f[0]=arr[0],g[n-1]=arr[n-1];
>     /*dp function*/
>     for(int i=1;i<n;++i) f[i]=max(f[i-1],arr[i]);
>     for(int i=n-2;i>-1;--i) g[i]=min(g[i+1],arr[i]);
>     dfs(arr,0,n-1);
>     return ret;
> }
> ```

> 山脉数组 https://leetcode.cn/problems/longest-mountain-in-array/description/
>
> ```c++
> int longestMountain(vector<int>& arr) {
>     int n=arr.size();
>     if(n<3) return 0;
>     vector<int> f(n),g(n);
>     /* 
>         f[i]::=以[i]为结尾的严格递增子数组长度 
>         g[i]::=以[i]为开始的严格递减子数组长度	
>     */
>     
>     f[0]=1,g[n-1]=1;
>     /* dp function */
>     for(int i=1;i<n;++i){
>         if(arr[i]>arr[i-1]) f[i]=1+f[i-1];
>         else f[i]=1;
>     }
>     for(int i=n-2;i>-1;--i){
>         if(arr[i]>arr[i+1]) g[i]=1+g[i+1];
>         else g[i]=1;
>     }
> 
>     int ret=0;
>     for(int i=1;i<n-1;++i){
>         int len=0;
>         if(f[i]>1 and g[i]>1) len=f[i]+g[i]-1; /* Note:不可以峰顶作端点 */
>         if(len>=3) ret=max(ret,len);
>     }
>     return ret;
> }
> ```

> 分组得分 https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/description/
>
> ```c++
> vector<int> maxScoreIndices(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n+1),g(n+1);
>     /* 
>         f[i]::=[0,i) '0'计数 
>         g[i]::=[i,n) '1'计数
>     */
>     
>     //dp function
>     for(int i=1;i<=n;++i){
>         f[i]=f[i-1];
>         if(nums[i-1]==0) ++f[i];
>     }
>     for(int i=n-1;i>-1;--i){
>         g[i]=g[i+1];
>         if(nums[i]==1) ++g[i];
>     }
>     
>     vector<int> ret;
>     int highest=0;
>     for(int i=0;i<=n;++i){
>         if(f[i]+g[i]>highest){
>             highest=f[i]+g[i];
>             ret.clear();
>             ret.push_back(i);
>         }else if(f[i]+g[i]==highest){
>             ret.push_back(i);
>         }
>     }
>     return ret;
> }
> ```

# 最优子数组

> 最大子数组和 https://leetcode.cn/problems/maximum-subarray/description/
>
> ```c++
> int maxSubArray(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> dp(n);
>     //dp[i]::=以i位置为结尾的最大子数组和
>     
>     dp[0]=nums[0];
>     int ret=dp[0];
>     for(int i=1;i<n;++i){
>         dp[i]=max(dp[i-1]+nums[i],nums[i]); //dp function
>         ret=max(ret,dp[i]);
>     }
>     return ret;
> }
> ```

> 环形最大子数组和 https://leetcode.cn/problems/maximum-sum-circular-subarray/description/
>
> ***环形问题可以考虑逆向转为线性问题***
>
> ```c++
> int maxSubarraySumCircular(vector<int>& nums) {
>     int n=nums.size();
>     int sum=accumulate(nums.begin(),nums.end(),0);
>     vector<int> f(n),g(n); 
>     //f[i]::=以i位置为结尾的最大子数组和
>     //g[i]::=以i位置为结尾的最小子数组和
>     
>     f[0]=g[0]=nums[0];
>     int f_max=f[0],g_min=g[0];
>     for(int i=1;i<n;++i){
>         f[i]=max(f[i-1]+nums[i],nums[i]); //dp function
>         g[i]=min(g[i-1]+nums[i],nums[i]);
>         f_max=max(f_max,f[i]);
>         g_min=min(g_min,g[i]);
>     }
>     
>     if(g_min==sum) return f_max; /* special case */
>     return max(f_max,sum-g_min);
> }
> ```

> 可删一次的最大子数组和 https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/
>
> ```c++
> int maximumSum(vector<int>& arr) {
>     int n=arr.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的最大子数组和(不删除)
>     //g[i]::=以i位置为结尾的最大子数组和(删除任意1个)
>     
>     f[0]=arr[0],g[0]=0;
>     int res=f[0];
>     for(int i=1;i<n;++i){
>         //dp function
>         f[i]=max(arr[i],f[i-1]+arr[i]);
>         g[i]=max(g[i-1]+arr[i],f[i-1]);/* g[i-1]+arr[i]表示删非i位置,f[i-1]表示删i位置 */
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 乘积最大子数组 https://leetcode.cn/problems/maximum-product-subarray/description/
>
> ```c++
> int maxProduct(vector<int>& nums) {
>     int n=nums.size();
>     vector<int> f(n),g(n);
>     //f[i]::=以i位置为结尾的乘积最大
>     //g[i]::=以i位置为结尾的乘积最小
>     
>     f[0]=g[0]=nums[0];
>     int res=nums[0];
>     for(int i=1;i<n;++i){
>         int x=nums[i];
>         //dp function 
>         if(x>=0){
>             f[i]=max(f[i-1]*x,x);
>             g[i]=min(g[i-1]*x,x);
>         }else{
>             f[i]=max(g[i-1]*x,x);
>             g[i]=min(f[i-1]*x,x);
>         }
>         res=max(res,max(f[i],g[i]));
>     }
>     return res;
> }
> ```

> 湍流子数组 https://leetcode.cn/problems/longest-turbulent-subarray/description/
>
> ```c++
> int maxTurbulenceSize(vector<int>& arr) {
>     int n=arr.size();
>     if(n==1) return 1;
>     vector<int> f(n); //f[i]::=以i为结尾的湍流子数组长度
>     f[0]=1,f[1]=arr[0]==arr[1]?1:2;
>     int res=max(f[0],f[1]);
>     for(int i=2;i<n;++i){
>         int a=arr[i],b=arr[i-1],c=arr[i-2]; /* 判断可否拼接 */
>         //dp function 
>         if(b>c and b>a or b<c and b<a) f[i]=f[i-1]+1;
>         else f[i]=b==a?1:2;
>         res=max(res,f[i]);
>     }
>     return res;
> }
> ```

# 数组划分

> 分割数组以求最大和 https://leetcode.cn/problems/partition-array-for-maximum-sum/description/
>
> ```c++
> int maxSumAfterPartitioning(vector<int>& arr, int k) {
>     int n=arr.size();
>     vector<int> dp(n+1);
>     /*
>             dp[i]::=拆分数组前i项得到的最大和
>             dp[0]=0凑数(前0项)
>     */
> 
>     for(int i=1;i<=n;++i){
>         int m=arr[i-1];
>         for(int j=1;j<=k and i>=j;++j){
>             m=max(m,arr[i-j]);
>             dp[i]=max(dp[i-j]+m*j,dp[i]); //dp function
>         }
>         /*
>                 m::=arr[i-j,i-1]的最大值
>                 dp[i]=max{dp[i-j]+m*j , ... , dp[i-k]+m*k};
>         */
>     }
>     return dp[n];
> }
> ```

> 填充书架 https://leetcode.cn/problems/filling-bookcase-shelves/
>
> ```c++
> /* 局部最优不可导出全局最优 */
> int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
>     int n=books.size();
>     vector<int> dp(n+1,0x3f3f3f3f);
>     dp[0]=0;
>     /*
>             dp[i]::=前i本书的最小排布高度
>             dp[0]=0 凑数
>     */
> 
>     for(int i=1;i<=n;++i){ /* 等价于分割数组以求最小和 */
>         int h=books[i-1][1];
>         int w=0;
>         for(int j=1;j<=i and books[i-j][0]+w<=shelfWidth;++j){
>             h=max(h,books[i-j][1]);
>             dp[i]=min(dp[i-j]+h,dp[i]); /* 把后几本书放在一排 */
>             w+=books[i-j][0];
>         }
>     }
>     return dp[n];
> }
> ```

> 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/description/
>
> ```c++
> 
> ```
>
> 分割回文串2 https://leetcode.cn/problems/palindrome-partitioning-ii/description/
>
> ```c++
> 
> ```

> 最低票价 https://leetcode.cn/problems/minimum-cost-for-tickets/description/
>
> ```c++
> 
> ```

> 单词拆分 https://leetcode.cn/problems/word-break/description/
>
> ```c++
> 
> ```
>
> 单词拆分II https://leetcode.cn/problems/word-break-ii/description/
>
> ```c++
> 
> ```