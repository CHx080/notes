# HTTPS
HTTP协议在网络中是以明文形式进行传输的，数据不经过任何的加密直接流向网络，这种方式是存在安全隐患的，在网络传输过程中信息容易被窃取和篡改。因此有必要对原数据进行加密保护，所谓HTTPS就是在原有的HTTP协议之上在附加一层安全协议SSL，HTTPS报文在网络中是以密文形式进行传输的，具有较高的安全性。

## 加密方式

### 对称加密

使用相同的密钥对数据进行加密和解密，那么就称这种方式为**对称加密**，其特点是**计算量小**，加密解密**速度快**，所面临的问题是如何安全在建立连接时**安全地传递对称密钥。**

### 非对称加密

使用不同地密钥对数据进行加密和解密，那么就称这种方式为**非对称加密**，两个密钥分别称为**公钥**和**私钥**，公钥可以在网络中传输，是公开的；私钥不能出现在网络中，受严格地保护，绝大多数情况下都是使用公钥加密私钥解密；非对称加密的**安全强度高**，但是**加密效率低于对称加密。**

## HTTPS衍进

### v1,仅对称加密

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c49a2b7010c74958a4ca932ab456626b.png)


客户端和服务端经过密钥协商确定了对称密钥并将其保存在本地，之后双方通信时通过密钥加密和解密，如果中间人在密钥协商之后到来，那么这种方式是没有问题的，因为中间人来迟了(截获不到密钥了)；但是问题在于密钥协商阶段中间人就发起了攻击，前面提到**对称加密面对的最大问题是如何安全地传输密钥**。

直接明文形式发送密钥？当然不行，中间人一旦截获它那么加密就形同虚设了。

以密文形式发送密钥？也不行，密钥的密钥怎么传输？

因此仅使用对称加密存在严重漏洞。

### v2,单方非对称加密

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0050d6e24c184b9ba02f54043aead987.png)


假设服务端将私钥S保存在本地，通过网络向客户端告知公钥P，客户端收到后使用服务端告知的公钥对数据进行加密，服务端收到密文后通过私钥解密，这是安全的，因为即便中间人获得了公钥，也是没有用的，因此欲解密必须知道私钥。

但是问题来了，之后服务端以明文形式给客户端发送信息，客户端没办法解密(*客户端也不知道私钥*)，那就出问题了。因此不能仅一方使用非对称加密，这只能保证单方通信的安全。

### v3,双方非对称加密

客户端和服务端都保存各自的私钥于本地，密钥协商阶段交换彼此的公钥。

客户端通过服务端的公钥加密数据，服务端通过自己的私钥解密数据。

服务端通过客户端的公钥加密数据，客户端通过自己的私钥解密数据。

由此双端的通信看似都可以实现安全传输了，但是非对称加密的效率太低了，网络速度本来就较慢，频繁的使用非对称加密更是严重降低效率。

### v4，**对称加密+非对称加密**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5a066190337d48f28948b8f8496d29cf.png)


**密钥协商流程：**

1. 服务端将公钥P告知客户端
2. 客户端收到公钥P后生成一个对称密钥X
3. 使用P对X加密后告知服务端
4. 服务端得到X的密文数据后通过私钥S解密获得X
5. 至此双方以安全的得到对称密钥X，此后通信通过对称加密保护

**核心理念在于通过非对称加密传输对称密钥，通过对称加密传输正文。**

### v5,对称加密+非对称加密+CA证书

v4版本的https已经可以解决部分的安全问题了，但是这都是鉴于中间人在密钥协商阶段只读不写的情况下(*v1~v4的方式都没有考虑中间人修改公钥的情况*)

*case : 中间人在密钥协商阶段直接调包了公钥*

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c6a35e10669c4c35895b7f4451599704.png)


1. 服务端给客户端公钥P
2. 中间人拿走P并置换成自己的公钥M
3. 客户端收到M后生成X，并通过M加密X返回
4. 中间人截获到X的密文数据，通过私钥C获得X
5. 中间人将X经过P加密给服务端
6. 服务端通过S解密获得X

**这会导致安全问题，因为密钥协商阶段达成的对称密钥X对中间人来说是已知的，那么中间人就有能力对双方的通信数据进行解密读取。**

*那么如何解决问题，先来思考一下为什么中间人能成功攻击*

#### 中间人成功攻击本质原因

1. *中间人可以随意地修改公钥数据*
2. *客户端不知道公钥被篡改过（无法验证公钥合法性）*

↓

知道原因后就可以对症下药了，为了保证公钥的合法性，就必须有权威机构的保证，**CA证书用来保证公钥合法性**。

#### **CA认证**  

服务器在使用https之前需要向**CA机构**申请一份数字证书，数字证书里含有申请者信息、**公钥信息**、数据签名。服务器把证书传给浏览器，**浏览器从证书里获取公钥**。（**数字证书里是不包含服务端的私钥的**）

CA证书可以分为**认证+签名**两个部分，其中**认证以明文显示，签名以密文显示**

##### 数据指纹(数据摘要)

利用单向散列函数对数据计算，生成一串散列值，它不是一种加密机制，只是用来数据有无被篡改（*linux中mdsum5命令）*，只要数据发生修改，散列值会发生变化

##### 数据签名

经过**非对称加密**后的数据指纹（数据摘要），之所以对数据指纹加密而不是原数据加密的原因是需要提高加密速度*(数据指纹的长度一般都远小于原数据长度)*

##### 证书合法性保证

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9a157a3bab11432d8bf86900e08e00d2.png)


为了阻止中间人使用虚假证书调包真的CA证书，需要借助数据签名，CA机构收到会对申请者提交的申请信息经过散列计算得到**数据指纹**，再使用**机构专有的私钥**（*机构专有的公钥已经内置于浏览器，经过机构专有的私钥加密形成数据签名只能使用机构专有公钥解密*）对数据指纹加密形成数据签名，最后将申请信息与数据签名合并形成CA证书颁发给申请者

当客户端收到来自服务端的数据时，第一步就是验证证书的合法性

1. 通过散列函数对明文认证信息进行计算求出数据指纹1
2. 通过内置的CA公钥对密文数据签名解密获得数据指纹2
3. 比较数据指纹1和数据指纹2，如果不一致，则判定为假证书

这样一来中间人无论是修改认证信息还是数据签名，都会导致最终的签名值不匹配，客户端可以识别出数据遭到了篡改。*（如果中间人将认证信息和数据签名整体调包，由于客户端不知道中间人的公钥，即使拿到了假证书，也不无法对数据签名作解密操作；如果中间人换上的的确是一个真证书，那么就会被法律溯源了）*